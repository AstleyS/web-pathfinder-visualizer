{"version":3,"sources":["Node/Node.jsx","Node/NodeObj.js","algorithms/bfsOrDfs.js","algorithms/dijkstraOrAS.js","PathFinderVisualizer/PathFinderVisualizer.jsx","Header/Header.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","isStart","isFinish","coordinates","extraClassName","id","className","React","Component","NodeObj","col","row","previous","cost","Infinity","heuristic","totalCost","validNeighbours","algo","paths","visited","node","dimension","nodeF","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","add","previousNode","push","unshift","console","log","x1","y1","x2","y2","Math","floor","sqrt","findNodeF","prevX","prevY","getNode","newCost","abs","currentCost","newNode","h","SPEED","PathFinderVisualizer","playAlgo","reset","play","setPlay","resetPath","setResetPath","nodeS","nodes","maxRow","maxCol","start","finish","currentRow","currentNode","generateGrid","bfsOrDFS","dijkstraOrAS","querySelectorAll","forEach","style","background","remove","disabled","clearPath","map","rIndex","nodeIndex","grid","length","time","i","shift","pop","bfsOrDfsAlgo","timeEnd","animateAlgorithm","animatePath","sort","a","b","dijkstraOrASAlgo","slice","visitedNodes","setTimeout","lastTime","dest","finalPath","replace","innerText","changeAfterPlay","Header","setAlgo","Navbar","collapseOnSelect","expand","variant","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","onClick","chooseAlgo","Divider","Link","Button","color","changeOnAlgo","App","useState","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.9977cbc8.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default class Node extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n\n    render() {\n        // Getting the attributes (Passed in PathfinderVisualizer.jsx render() <Node [atributtes]>)\n        const { isStart, isFinish, coordinates } = this.props;\n        const extraClassName = isStart ? 'node-start visited': isFinish ? 'node-finish' : '';\n\n        return <div id={`${ coordinates }`} className={`node ${ extraClassName }`}></div>;\n    }\n\n}","export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n    heuristic;\n    totalCost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n            this.heuristic = Infinity;\n            this.totalCost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../Node/NodeObj';\n\n// If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* SHIFT: REMOVE AT BEGINNING | PUSH: ADD AT LAST */\n    \n// If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* POP: REMOVE AT LAS | UNSHIFT: ADD AT BEGINNING */\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    while (paths.length > 0 && i <= dimension[0] * dimension[1]) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        let node = algo === 'BFS' ? paths.shift(): paths.pop();\n        console.log({node});\n        \n        // Check the valid neighbours\n        let foundNodeF = validNeighbours(algo, paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        \n        i++;\n    }\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited or if it's a wall\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\")) return true;\n\n    // If not, adds it\n    node.classList.add(\"visited\");\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(algo, paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n    // If BFS, adds the node to the end of the queue || end of the array\n    if (algo === 'BFS') {\n        paths.push(node);\n        visited.push(node);\n    // If DFS, adds the node to the top of the stack || start of the array\n    } else if (algo === 'DFS') {\n        paths.unshift(node);\n        visited.push(node);\n    }\n\n    // Check if its end node\n    if (nodeF.row === y && nodeF.col === x) {\n        node.isFinish = true;\n        console.log(`%c Found`, 'color: brown');\n        return true;\n    }\n    \n    return false;\n}","import Node from '../Node/NodeObj';\n\n// Priority Queue\n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const dijkstraOrAS = (algo, dimension, nodeS, nodeF) => {\n\n    // Check if nodes are in the same position | Disable this when given use option\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    nodeS.cost = 0;\n    \n    // Check if AStar to add heuristic\n    if (algo === 'AStar') {\n        nodeS.heuristic = heuristic(nodeS, nodeF);\n        nodeS.totalCost = nodeS.heuristic + nodeS.cost;\n    }\n    \n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n    \n    let i = 0;\n    // While there are unvisited nodes and node not found\n    // We need also to check if loop didn't reach the maximum iteration possible to prevent browser to crash\n    while (paths.length > 0 && i <= dimension[0] * dimension[1] * 4) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let node = paths.shift();  \n        console.log('Shit');\n        console.log({node});\n        \n        // If we found the node then we should get rid of the other nodes \n        if (findNodeF(node, nodeF)) {\n            console.log(`%c Found`, 'color: brown');\n            visited.push(node);\n            \n            return [visited, true];\n        }\n    \n        // Mark as visited\n        // With the DOM manipulation, I don't have to traverse the {visited} list: O(1) \n        document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n        visited.push(node);\n\n        validNeighbours(algo, paths, node, dimension, nodeF);\n\n        // Order neighbours by the cost to travel to\n        if (algo === 'AStar') {\n            paths.sort((a, b) => a.totalCost - b.totalCost);\n        } else if (algo === 'Dijkstra') {\n            paths.sort((a, b) => a.cost - b.cost);\n        } \n        //console.log({paths});\n        i++;\n    }\n\n    return [visited, false];\n}\n\n// This function calculates the heuristic\nfunction heuristic(node, nodeF) {\n\n    // Node coordinate\n    const x1 = node.col;\n    const y1 = node.row;\n    \n    // Node Finish coordinate\n    const x2 = nodeF.col;\n    const y2 = nodeF.row;\n\n    // The heuristic is the distance between the sqrt((x2-x1)² + (y2-y1)²) \n    const heuristic = Math.floor(Math.sqrt(((x2-x1) ** 2) + ((y2-y1) ** 2)));\n    //console.log(`Heuristic ${heuristic}`);\n    node.heuristic = heuristic;\n    \n    return heuristic;\n}\n\n// This function checks if a given node is the finish node\nfunction findNodeF(node, nodeF) {\n    return node.row === nodeF.row && node.col === nodeF.col;\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(algo, paths, node, [x, y - 1], nodeF);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(algo, paths, node, [x + 1, y], nodeF);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(algo, paths, node, [x, y + 1], nodeF);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(algo, paths, node, [x - 1, y], nodeF);\n        }\n    }\n}\n\n// This function checks if the node was already visited\n// The reason why I am not checking the visited list\n// is due to the runtime performance\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\")) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(algo, paths, previousNode, coordinate, nodeF) {\n    \n    // Previous node coordinate\n    const prevX = previousNode.col;\n    const prevY = previousNode.row;\n    \n    // Node (neighbour) coordinate\n    const x = coordinate[0];\n    const y = coordinate[1];\n    \n    let node = getNode(paths, x, y);\n    console.log('Neighbour');\n    \n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    // This is equivallent to EDGE + ACCUMULATED COST \n    const newCost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n    \n    // Getting the cost of the node (the neighbour node) if already in paths. IF not returns Infinity\n    const currentCost = node.cost;\n\n    // This variable flags if node was updated or is new \n    const newNode = node.cost === Infinity;\n    \n    // Update the cost if cost is smaller than the node's atual cost\n    if (newCost <= currentCost) {\n        node.cost = newCost;\n        node.previous = previousNode;\n    }\n    \n    // If the algo is A* then we need to add the heuristic and update the total cost\n    if (algo === 'AStar') {\n        const h = heuristic(node, nodeF);\n        node.totalCost = node.cost + h;\n    }\n\n    // If we find the nodeF then we will flag it\n    if (findNodeF(node, nodeF)) {\n        node.isFinish = true;\n    }\n\n    console.log({node});\n    \n    // If its a new node, adds to the list\n    if (newNode) paths.push(node);\n    console.log({paths});\n}\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getNode(paths, x, y) {\n    // If it was already opened, returns the node\n    for (let node of paths) {\n        if (node.col === x && node.row === y) return node;\n    }\n\n    // Else, returns a new node\n    return new Node(x, y, false, false);\n}\n","import React from 'react';\nimport './PathFinderVisualizer.css';\n\nimport Node from '../Node/Node';\nimport NodeObj from '../Node/NodeObj';\n\n// Import the algorithm functions\nimport { bfsOrDfs as bfsOrDfsAlgo } from '../algorithms/bfsOrDfs';\nimport { dijkstraOrAS as dijkstraOrASAlgo } from '../algorithms/dijkstraOrAS';\n\nconst ROW = 20;\nconst COLUMN = 30;\n\n// Has to be less than columns\nconst START_X = 8;\n// Has to be less than row\nconst START_Y = 7;\n\n// Has to be less than columns\nconst FINISH_X = 18;\n// Has to be less than row\nconst FINISH_Y = 10;\n\nconst SPEED = 110; // The less the more speed\n\nexport default function PathFinderVisualizer({algo, playAlgo, reset}) {\n\n    // Decostructing the objects passed by arguments \n    const { play, setPlay } = playAlgo;\n    const { resetPath, setResetPath } = reset;\n\n    const nodeS = new NodeObj(START_X, START_Y, true, false);\n    const nodeF = new NodeObj(FINISH_X, FINISH_Y, false, true);\n    \n    const nodes = generateGrid(ROW, COLUMN, [START_X, START_Y], [FINISH_X, FINISH_Y]); \n    console.log({nodes});\n\n    console.log({algo});\n    console.log({play});\n    console.log({resetPath});\n\n    // Check if the play button was clicked and start the chosen algorithm\n    if (play) {\n        switch(algo) {\n            case 'BFS': \n                bfsOrDFS('BFS', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'DFS': \n                bfsOrDFS('DFS', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'Dijkstra': \n                dijkstraOrAS('Dijkstra', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'AStar': \n                dijkstraOrAS('AStar', nodes, nodeS, nodeF, setPlay);\n                break;\n            default:\n                console.log('Algo not found');\n        }\n    }\n\n    // Check if the clear path button was clicked\n    if (resetPath) {\n        clearPath(setResetPath);\n    } \n\n    return (\n        <div className = \"container-fluid\">\n            <div className=\"grid\">\n                {\n                    nodes.map((row, rIndex) => {\n                        return <div key={ rIndex } className=\"grid-row\" >\n                            {\n                            row.map((node, nodeIndex) => {\n                                const { isStart, isFinish, col, row } = node;\n                                return <Node\n                                    coordinates={`${col},${row}`} key={ nodeIndex }\n                                    isStart = { isStart } isFinish = { isFinish }\n                                ></Node>\n                            })\n                            }\n                        </div>\n                    })\n                }\n            </div>\n        </div>\n    )\n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol, start, finish) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = new NodeObj(\n                    col,\n                    row,\n                    row === start[1] && col === start[0],\n                    row === finish[1] && col === finish[0]\n                );\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode);\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function handles the user click when choosing BFS or DFS\nfunction bfsOrDFS(algo, grid, nodeS, nodeF, setPlay) {\n    // DIMENSION: 0 = ROW | 1 = COLUMN\n    const dimension = [grid.length, grid[0].length];\n\n    console.time(\"runtime\");\n\n    // This variable holds the result of the BFS algorithm visisted nodes\n    // [0] = visited nodes [1] = found node\n    \n    console.log({nodeS, nodeF});\n    const nodes = bfsOrDfsAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    console.log({visited});\n        \n    console.timeEnd(\"runtime\");\n        \n   animateAlgorithm(visited);\n   \n   // The first args refers to the time that the animateAlgorithm finished + 50ms\n   // The seconde args return the last node a.k.a nodeF\n   if (nodes[1]) animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay); \n}\n\n// This function handles the user click when choosing Dijsktra\nfunction dijkstraOrAS(algo, grid, nodeS, nodeF, setPlay) {\n    const dimension = [grid.length, grid[0].length];\n\n    console.time('runtime');\n    \n    const nodes = dijkstraOrASAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    console.log({visited});\n\n    console.timeEnd('runtime');\n\n    // With slice(0) we are including nodeS\n    animateAlgorithm(visited.slice(1));\n\n    // The first args refers to the time that the animateAlgorithm finished + 50ms\n    // The seconde args return the last node a.k.a nodeF\n    if (nodes[1]) animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay);\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n        if (i !== visitedNodes.length - 1) {\n            // With setTimeout, we change the color of each visited node with SPEED time between them\n            setTimeout(() => {\n                if (!node.isFinish) {\n                    document.getElementById(`${node.col},${node.row}`).style.background = \"lightblue\";\n                } else {\n                    document.getElementById(`${node.col},${node.row}`).style.background = \"red\";\n                }\n            } , SPEED * i);\n        }\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(lastTime, nodeF, setPlay) {\n\n    // Get the last node a.k.a last visited node\n    let dest = nodeF\n    console.log({dest});\n    const finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    console.log({finalPath});\n        \n    // The last node is the nodeS, so we wont count it\n    for (let i = finalPath.length - 2; i >= 0; i--) {\n        setTimeout(() => {\n            const node = finalPath[i]\n            if (node.isFinish) {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"yellow\";\n                changeAfterPlay(setPlay);\n\n            } else {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"purple\";\n            }\n           // time of the last animation + time for the next animations\n        } , lastTime + ( SPEED * (finalPath.length - i) ));\n    }\n}\n\n// This function clears the path\nfunction clearPath(setResetPath) {\n\n    // Reset any stylization\n    let nodes = document.querySelectorAll('.node');\n    nodes.forEach((node) => {\n        if (node.style.background !== '') node.style.background = '';\n        if (node.classList.contains('visited') && !node.classList.contains('node-start')) node.classList.remove('visited');\n    });\n\n    // Set the clear path button\n    setResetPath(false);\n    document.getElementById('clearPath-btn').disabled = true;\n    document.getElementById('play-btn').disabled = false;\n}\n\n// This functions change some elements state\nfunction changeAfterPlay(setPlay) {\n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.remove('disabled');;\n\n    // Change play button state\n    document.getElementById('play-btn').classList.replace('btn-danger', 'btn-success');\n    document.getElementById('play-btn').innerText = 'Play';\n\n    setPlay(false);\n\n    // Change clear path state\n    document.getElementById('clearPath-btn').disabled = false;\n} ","import React from 'react';\nimport './Header.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\n\nexport default function Header({ setAlgo, setPlay, setResetPath }) {\n\n    return (\n        <Navbar id=\"navbar\" collapseOnSelect expand=\"sm\" variant=\"dark\">\n            <Navbar.Brand>PathFinder</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n            <Nav className=\"mr-auto\">\n                <NavDropdown id=\"collasible-nav-dropdown\" className=\"btn\" title=\"Choose Algorithm\"  variant=\"dark\">\n                    <NavDropdown.Item onClick={() => chooseAlgo('BFS', setAlgo)}>BFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => chooseAlgo('DFS', setAlgo)}>DFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => chooseAlgo('Dijkstra', setAlgo)}>Dijkstra</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => chooseAlgo('AStar', setAlgo)}>A*</NavDropdown.Item>\n                </NavDropdown>\n                <Nav.Link><Button variant=\"info\" disabled>Add Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => playAlgo(setPlay)}><Button id='play-btn' variant=\"success\" disabled>Play</Button></Nav.Link>\n            </Nav>\n            <Nav>\n                <Nav.Link><Button variant=\"warning\" disabled>Clear Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => resetPath(setResetPath)}><Button id='clearPath-btn' variant=\"danger\" disabled>Clear Path</Button></Nav.Link>\n            </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}\n\n// This function updates the algorithm state\nfunction chooseAlgo(algo, setAlgo) {\n    setAlgo(algo);\n    \n    changeOnAlgo(algo);\n\n}\n\n// This function updates the play state\nfunction playAlgo(setPlay) {\n    setPlay(true);\n\n    changeOnPlay();\n}\n\n// This function updates the resetPath state\nfunction resetPath(setResetPath) {\n    setResetPath(true);\n}\n\n/* These functions change some elements state */\nfunction changeOnAlgo(algo) {\n    // Manipulate the choose algorithm title\n    document.getElementById('collasible-nav-dropdown').innerText = algo;\n    document.getElementById('collasible-nav-dropdown').style.color = 'lightgreen';\n    \n    // Manipulate the play btn\n\n    // Only activate play btn if clear path is disabled. \n    // If it is enable it means that the user did not clear the path yet, hence not activating the play button\n    if (document.getElementById('clearPath-btn').disabled) {\n        document.getElementById('play-btn').disabled = false;\n    }\n}\n\nfunction changeOnPlay() {\n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n\n    // Change play button state\n    document.getElementById('play-btn').classList.replace('btn-success', 'btn-danger');\n    document.getElementById('play-btn').innerText = 'Searching for path...';\n    document.getElementById('play-btn').disabled = true;\n\n    // Change clear path button state\n    document.getElementById('clearPath-btn').disabled = true;\n}","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\nimport Header from './Header/Header';\nimport React, { useState } from 'react';\n\nexport default function App() {\n  \n  const [algo, setAlgo] = useState('');\n  const [play, setPlay] = useState(false);\n  const [resetPath, setResetPath] = useState(false);\n\n  return (\n    <div className=\"App\">\n      <Header setAlgo = { setAlgo } setPlay = { setPlay } setResetPath = { setResetPath }></Header>\n      <PathFinderVisualizer algo = { algo } playAlgo = { { play, setPlay } } reset = { { resetPath, setResetPath } } ></PathFinderVisualizer>\n    </div>\n  );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}