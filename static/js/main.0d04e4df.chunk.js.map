{"version":3,"sources":["Node/Node.js","algorithms/bfsOrDfs.js","algorithms/dijkstraOrAS.js","PathFinderVisualizer/PathFinderVisualizer.jsx","Header/Header.jsx","App.js","reportWebVitals.js","index.js"],"names":["NodeObj","col","row","isStart","isFinish","this","previous","cost","Infinity","heuristic","totalCost","validNeighbours","algo","paths","visited","node","dimension","nodeF","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","add","previousNode","Node","push","unshift","console","log","x1","y1","x2","y2","Math","floor","sqrt","findNodeF","prevX","prevY","getNode","newCost","abs","currentCost","newNode","h","SPEED","PathFinderVisualizer","walls","playAlgo","resetW","resetP","play","setPlay","resetWalls","setResetWalls","resetPath","setResetPath","nodeS","nodes","maxRow","maxCol","start","finish","currentRow","currentNode","generateGrid","grid","length","time","i","shift","pop","bfsOrDfsAlgo","timeEnd","animateAlgorithm","animatePath","changeAfterPlay","bfsOrDFS","dijkstraOrAS","querySelectorAll","forEach","wall","remove","style","background","disabled","clearWalls","clearPath","className","map","rIndex","nodeIndex","extraClassName","onClick","addNodeWalls","id","sort","a","b","dijkstraOrASAlgo","slice","visitedNodes","setTimeout","lastTime","dest","finalPath","replace","innerText","Header","setAlgo","setWalls","Navbar","collapseOnSelect","expand","variant","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","changeOnAlgo","Divider","Link","addWallsBtn","changeOnAddWalls","Button","playBtn","changeOnPlay","color","App","useState","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.0d04e4df.chunk.js","sourcesContent":["export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n    heuristic;\n    totalCost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n            this.heuristic = Infinity;\n            this.totalCost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../Node/Node';\n\n// If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* SHIFT: REMOVE AT BEGINNING | PUSH: ADD AT LAST */\n    \n// If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* POP: REMOVE AT LAS | UNSHIFT: ADD AT BEGINNING */\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    while (paths.length > 0 && i <= dimension[0] * dimension[1]) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        let node = algo === 'BFS' ? paths.shift(): paths.pop();\n        console.log({node});\n        \n        // Check the valid neighbours\n        let foundNodeF = validNeighbours(algo, paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        \n        i++;\n    }\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited or if it's a wall\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\")) return true;\n\n    // If not, adds it\n    node.classList.add(\"visited\");\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(algo, paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n    // If BFS, adds the node to the end of the queue || end of the array\n    if (algo === 'BFS') {\n        paths.push(node);\n        visited.push(node);\n    // If DFS, adds the node to the top of the stack || start of the array\n    } else if (algo === 'DFS') {\n        paths.unshift(node);\n        visited.push(node);\n    }\n\n    // Check if its end node\n    if (nodeF.row === y && nodeF.col === x) {\n        node.isFinish = true;\n        console.log(`%c Found`, 'color: brown');\n        return true;\n    }\n    \n    return false;\n}","import Node from '../Node/Node';\n\n// Priority Queue\n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const dijkstraOrAS = (algo, dimension, nodeS, nodeF) => {\n\n    // Check if nodes are in the same position | Disable this when given use option\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    nodeS.cost = 0;\n    \n    // Check if AStar to add heuristic\n    if (algo === 'AStar') {\n        nodeS.heuristic = heuristic(nodeS, nodeF);\n        nodeS.totalCost = nodeS.heuristic + nodeS.cost;\n    }\n    \n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n    \n    let i = 0;\n    // While there are unvisited nodes and node not found\n    // We need also to check if loop didn't reach the maximum iteration possible to prevent browser to crash\n    while (paths.length > 0 && i <= dimension[0] * dimension[1] - 2) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let node = paths.shift();  \n        console.log('Shit');\n        console.log({node});\n        \n        // If we found the node then we should get rid of the other nodes \n        if (findNodeF(node, nodeF)) {\n            console.log(`%c Found`, 'color: brown');\n            document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n            visited.push(node);\n            \n            return [visited, true];\n        }\n    \n        // Mark as visited\n        // With the DOM manipulation, I don't have to traverse the {visited} list: O(1) \n        document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n        visited.push(node);\n\n        validNeighbours(algo, paths, node, dimension, nodeF);\n\n        // Order neighbours by the cost to travel to\n        if (algo === 'AStar') {\n            paths.sort((a, b) => a.totalCost - b.totalCost);\n        } else if (algo === 'Dijkstra') {\n            paths.sort((a, b) => a.cost - b.cost);\n        } \n        //console.log({paths});\n        i++;\n    }\n\n    return [visited, false];\n}\n\n// This function calculates the heuristic\nfunction heuristic(node, nodeF) {\n\n    // Node coordinate\n    const x1 = node.col;\n    const y1 = node.row;\n    \n    // Node Finish coordinate\n    const x2 = nodeF.col;\n    const y2 = nodeF.row;\n\n    // The heuristic is the distance between the sqrt((x2-x1)² + (y2-y1)²) \n    const heuristic = Math.floor(Math.sqrt(((x2-x1) ** 2) + ((y2-y1) ** 2)));\n    //console.log(`Heuristic ${heuristic}`);\n    node.heuristic = heuristic;\n    \n    return heuristic;\n}\n\n// This function checks if a given node is the finish node\nfunction findNodeF(node, nodeF) {\n    return node.row === nodeF.row && node.col === nodeF.col;\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(algo, paths, node, [x, y - 1], nodeF);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(algo, paths, node, [x + 1, y], nodeF);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(algo, paths, node, [x, y + 1], nodeF);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(algo, paths, node, [x - 1, y], nodeF);\n        }\n    }\n}\n\n// This function checks if the node was already visited\n// The reason why I am not checking the visited list\n// is due to the runtime performance\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\") ) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(algo, paths, previousNode, coordinate, nodeF) {\n    \n    // Previous node coordinate\n    const prevX = previousNode.col;\n    const prevY = previousNode.row;\n    \n    // Node (neighbour) coordinate\n    const x = coordinate[0];\n    const y = coordinate[1];\n    \n    let node = getNode(paths, x, y);\n    console.log('Neighbour');\n    \n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    // This is equivallent to EDGE + ACCUMULATED COST \n    const newCost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n    \n    // Getting the cost of the node (the neighbour node) if already in paths. IF not returns Infinity\n    const currentCost = node.cost;\n\n    // This variable flags if node was updated or is new \n    const newNode = node.cost === Infinity;\n    \n    // Update the cost if cost is smaller than the node's atual cost\n    if (newCost <= currentCost) {\n        node.cost = newCost;\n        node.previous = previousNode;\n    }\n    \n    // If the algo is A* then we need to add the heuristic and update the total cost\n    if (algo === 'AStar') {\n        const h = heuristic(node, nodeF);\n        node.totalCost = node.cost + h;\n    }\n\n    // If we find the nodeF then we will flag it\n    if (findNodeF(node, nodeF)) {\n        node.isFinish = true;\n    }\n\n    console.log({node});\n    \n    // If its a new node, adds to the list\n    if (newNode) paths.push(node);\n    console.log({paths});\n}\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getNode(paths, x, y) {\n    // If it was already opened, returns the node\n    for (let node of paths) {\n        if (node.col === x && node.row === y) return node;\n    }\n\n    // Else, returns a new node\n    return new Node(x, y, false, false);\n}\n","import React from 'react';\nimport './PathFinderVisualizer.css';\n\nimport Node from '../Node/Node';\n\n// Import the algorithm functions\nimport { bfsOrDfs as bfsOrDfsAlgo } from '../algorithms/bfsOrDfs';\nimport { dijkstraOrAS as dijkstraOrASAlgo } from '../algorithms/dijkstraOrAS';\n\nconst ROW = 20;\nconst COLUMN = 30;\n\n// Has to be less than columns\nconst START_X = 8;\n// Has to be less than row\nconst START_Y = 7;\n\n// Has to be less than columns\nconst FINISH_X = 18;\n// Has to be less than row\nconst FINISH_Y = 10;\n\nconst SPEED = 110; // The less the more speed\n\nexport default function PathFinderVisualizer({algo, walls, playAlgo, resetW, resetP}) {\n\n    // Decostructing the objects passed by arguments \n    const { play, setPlay } = playAlgo;\n    const { resetWalls, setResetWalls } = resetW;\n    const { resetPath, setResetPath } = resetP;\n\n    const nodeS = new Node(START_X, START_Y, true, false);\n    const nodeF = new Node(FINISH_X, FINISH_Y, false, true);\n    \n    const nodes = generateGrid(ROW, COLUMN, [START_X, START_Y], [FINISH_X, FINISH_Y]); \n    console.log({nodes});\n\n    console.log({algo});\n    console.log({walls});\n    console.log({play});\n    console.log({resetWalls});\n    console.log({resetPath});\n\n    // Check if the play button was clicked and start the chosen algorithm\n    if (play) {\n        switch(algo) {\n            case 'BFS': \n                bfsOrDFS('BFS', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'DFS': \n                //bfsOrDFS('DFS', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'Dijkstra': \n                dijkstraOrAS('Dijkstra', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'AStar': \n                dijkstraOrAS('AStar', nodes, nodeS, nodeF, setPlay);\n                break;\n            default:\n                console.log('Algo not found');\n        }\n    }\n\n    // Check if the clear walls button was clicked\n    if (resetWalls) {\n        clearWalls(setResetWalls);\n    }\n\n    // Check if the clear path button was clicked\n    if (resetPath) {\n        clearPath(setResetPath);\n    }\n\n    return (\n        <div className = \"container-fluid\">\n            <div className=\"grid\">\n                {\n                    nodes.map((row, rIndex) => {\n                        return <div key = { rIndex } className = \"grid-row\" >\n                            {\n                            row.map((node, nodeIndex) => {\n                                const { isStart, isFinish, col, row } = node;\n                                const extraClassName = isStart ? 'node-start visited': isFinish ? 'node-finish' : '';\n                                const coordinate = [col, row];\n                                return ( \n                                    <div onClick = {() => addNodeWalls(coordinate, walls) } \n                                        id = {`${col},${row}`} \n                                        className = {`node ${ extraClassName }`} key = {nodeIndex}>\n                                    </div>\n                                )\n                            })\n                            }\n                        </div>\n                    })\n                }\n            </div>\n        </div>\n    )\n}\n\nfunction addNodeWalls(coordinate, walls) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    if (walls) {\n\n        const walls = document.querySelectorAll('.wall');\n        if (walls.length > 1) document.getElementById('clearWalls-btn').disabled = false;\n\n        document.getElementById(`${x},${y}`).style.background = \"black\";\n        document.getElementById(`${x},${y}`).classList.add(\"wall\");\n    }\n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol, start, finish) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = new Node (\n                    col,\n                    row,\n                    row === start[1] && col === start[0],\n                    row === finish[1] && col === finish[0]\n                );\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode);\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function handles the user click when choosing BFS or DFS\nfunction bfsOrDFS(algo, grid, nodeS, nodeF, setPlay) {\n    // DIMENSION: 0 = ROW | 1 = COLUMN\n    const dimension = [grid.length, grid[0].length];\n\n    console.time(\"runtime\");\n\n    // This variable holds the result of the BFS algorithm visisted nodes\n    // [0] = visited nodes [1] = found node\n    \n    console.log({nodeS, nodeF});\n    const nodes = bfsOrDfsAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    console.log({visited});\n        \n    console.timeEnd(\"runtime\");\n        \n   animateAlgorithm(visited);\n   \n   // The first args refers to the time that the animateAlgorithm finished + 50ms\n   // The seconde args return the last node a.k.a nodeF\n   if (nodes[1]) {\n       animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay); \n   } else {\n       changeAfterPlay(setPlay);\n   }\n}\n\n// This function handles the user click when choosing Dijsktra\nfunction dijkstraOrAS(algo, grid, nodeS, nodeF, setPlay) {\n    const dimension = [grid.length, grid[0].length];\n\n    console.time('runtime');\n    \n    const nodes = dijkstraOrASAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    console.log({visited});\n\n    console.timeEnd('runtime');\n\n    // With slice(0) we are including nodeS\n    animateAlgorithm(visited.slice(1));\n\n    // The first args refers to the time that the animateAlgorithm finished + 50ms\n    // The seconde args return the last node a.k.a nodeF\n    if (nodes[1]) {\n        animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay);\n    } else {\n        changeAfterPlay(setPlay);\n    }\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n        if (i !== visitedNodes.length - 1) {\n            // With setTimeout, we change the color of each visited node with SPEED time between them\n            setTimeout(() => {\n                if (!node.isFinish) {\n                    document.getElementById(`${node.col},${node.row}`).style.background = \"lightblue\";\n                } else {\n                    document.getElementById(`${node.col},${node.row}`).style.background = \"red\";\n                }\n            } , SPEED * i);\n        }\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(lastTime, nodeF, setPlay) {\n\n    // Get the last node a.k.a last visited node\n    let dest = nodeF\n    console.log({dest});\n    const finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    console.log({finalPath});\n        \n    // The last node is the nodeS, so we wont count it\n    for (let i = finalPath.length - 2; i >= 0; i--) {\n        setTimeout(() => {\n            const node = finalPath[i]\n            if (node.isFinish) {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"yellow\";\n                changeAfterPlay(setPlay);\n\n            } else {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"purple\";\n            }\n           // time of the last animation + time for the next animations\n        } , lastTime + ( SPEED * (finalPath.length - i) ));\n    }\n}\n\n// This function clears the walls\nfunction clearWalls(setResetWalls) {\n    \n    setResetWalls(false);\n\n    // Reset any stylization\n    const walls = document.querySelectorAll('.wall');\n    walls.forEach((wall) => {\n        wall.classList.remove('wall');\n        wall.style.background = '';\n    });\n\n    document.getElementById('clearWalls-btn').disabled = true;\n}\n\n// This function clears the path\nfunction clearPath(setResetPath) {\n    \n    setResetPath(false);\n\n    // Reset any stylization\n    const nodes = document.querySelectorAll('.visited');\n    nodes.forEach((node) => {\n        if (!node.classList.contains('node-start')) node.classList.remove('visited');\n        node.style.background = '';\n    });\n\n    // Set the clear path button\n    document.getElementById('clearPath-btn').disabled = true;\n    document.getElementById('play-btn').disabled = false;\n    document.getElementById('addWalls-btn').disabled = false;\n}\n\n// This functions change some elements state\nfunction changeAfterPlay(setPlay) {\n    \n    setPlay(false);\n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.remove('disabled');;\n\n    // Change play button state\n    document.getElementById('play-btn').classList.replace('btn-danger', 'btn-success');\n    document.getElementById('play-btn').innerText = 'Play';\n\n    // Change clear path state\n    document.getElementById('clearPath-btn').disabled = false;\n\n    const walls = document.querySelectorAll('.wall');\n    if (walls.length > 1) document.getElementById('clearWalls-btn').disabled = false;\n    \n} ","import React from 'react';\nimport './Header.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\n\nexport default function Header({ setAlgo, setWalls, setPlay, setResetWalls, setResetPath }) {\n\n    return (\n        <Navbar id=\"navbar\" collapseOnSelect expand=\"sm\" variant=\"dark\">\n            <Navbar.Brand>PathFinder</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n            <Nav className=\"mr-auto\">\n                <NavDropdown id=\"collasible-nav-dropdown\" className=\"btn\" title=\"Choose Algorithm\"  variant=\"dark\">\n                    <NavDropdown.Item onClick={() => changeOnAlgo('BFS', setAlgo)}>BFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('DFS', setAlgo)}>DFS (not available yet)</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('Dijkstra', setAlgo)}>Dijkstra</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('AStar', setAlgo)}>A*</NavDropdown.Item>\n                </NavDropdown>\n                <Nav.Link onClick={() => changeOnAddWalls(setWalls)}><Button id='addWalls-btn' variant=\"info\" disabled>Add Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => changeOnPlay(setPlay)}><Button id='play-btn' variant=\"success\" disabled>Play</Button></Nav.Link>\n            </Nav>\n            <Nav>\n                <Nav.Link onClick = {() => resetWalls(setResetWalls)}><Button id='clearWalls-btn' variant=\"secondary\" disabled>Clear Walls</Button></Nav.Link>\n                <Nav.Link onClick = {() => resetPath(setResetPath)}><Button id='clearPath-btn' variant=\"danger\" disabled>Clear Path</Button></Nav.Link>\n            </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}\n\n/* These functions change some elements state */\nfunction changeOnAlgo(algo, setAlgo) {\n\n    setAlgo(algo);\n\n    // Manipulate the choose algorithm title\n    document.getElementById('collasible-nav-dropdown').innerText = algo;\n    document.getElementById('collasible-nav-dropdown').style.color = 'lightgreen';\n    \n    // Manipulate the play btn\n    // Only activate play and add walls btn if clear path is disabled. \n    // If it is enable it means that the user did not clear the path yet, hence not activating the play button\n    if (document.getElementById('clearPath-btn').disabled) {\n        document.getElementById('play-btn').disabled = false;\n        document.getElementById('addWalls-btn').disabled = false;\n    }\n}\n\nfunction changeOnAddWalls(setWalls) {\n    // Change add walls button state\n    const addWallsBtn = document.getElementById('addWalls-btn');\n\n    // Toggle\n    // ADD WALLS\n    if (addWallsBtn.classList.contains('btn-info')) {\n\n        setWalls(true);\n        \n        addWallsBtn.classList.replace('btn-info', 'btn-warning');\n        addWallsBtn.innerText = 'Enough of Walls';\n        \n        // Change choose algo dropdown state\n        document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n        \n        // Change play button state\n        document.getElementById('play-btn').disabled = true;\n\n    // STOP ADDING WALLS\n    } else if (addWallsBtn.classList.contains('btn-warning')) {\n        \n        setWalls(false);\n\n        addWallsBtn.classList.replace('btn-warning', 'btn-info');\n        addWallsBtn.innerText = 'Add Walls';\n\n        // Change choose algo dropdown state\n        document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n\n        // Change play button state\n        document.getElementById('play-btn').disabled = false;\n    \n    }\n}\n\nfunction changeOnPlay(setPlay) {\n    \n    setPlay(true);\n\n    const playBtn = document.getElementById('play-btn'); \n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n    \n    // Change add walls button state\n    document.getElementById('addWalls-btn').disabled = true;\n    \n    // Change play button state\n    playBtn.classList.replace('btn-success', 'btn-danger');\n    playBtn.innerText = 'Searching for path...';\n    playBtn.disabled = true;\n    \n    // Change clear walls button state\n    document.getElementById('clearWalls-btn').disabled = true;\n    // Change clear path button state\n    document.getElementById('clearPath-btn').disabled = true;\n}\n\n// This function updates the resetPath state\nfunction resetWalls(setResetWalls) {\n    setResetWalls(true);\n}\n\n// This function updates the resetPath state\nfunction resetPath(setResetPath) {\n    setResetPath(true);\n}","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\nimport Header from './Header/Header';\nimport React, { useState } from 'react';\n\nexport default function App() {\n  \n  const [algo, setAlgo] = useState('');\n  const [walls, setWalls] = useState(false);\n  const [play, setPlay] = useState(false);\n  const [resetWalls, setResetWalls] = useState(false);\n  const [resetPath, setResetPath] = useState(false);\n\n  return (\n    <div className=\"App\">\n      <Header \n        setAlgo = { setAlgo } setWalls = { setWalls } \n        setPlay = { setPlay } setResetWalls = { setResetWalls } setResetPath = { setResetPath }></Header>\n      <PathFinderVisualizer \n        algo = { algo } walls = { walls }\n        playAlgo = { {play, setPlay} } resetW = { {resetWalls, setResetWalls} } resetP = { {resetPath, setResetPath} }>\n       </PathFinderVisualizer>\n    </div>\n  );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}