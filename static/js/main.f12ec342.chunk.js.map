{"version":3,"sources":["Node/Node.js","algorithms/bfsOrDfs.js","algorithms/dijkstraOrAS.js","PathFinderVisualizer/PathFinderVisualizer.jsx","Header/Header.jsx","App.js","reportWebVitals.js","index.js"],"names":["NodeObj","col","row","isStart","isFinish","this","previous","cost","Infinity","heuristic","totalCost","validNeighbours","paths","visited","node","dimension","nodeF","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","previousNode","Node","console","log","add","push","x1","y1","x2","y2","Math","floor","sqrt","findNodeF","algo","prevX","prevY","getNode","newCost","abs","currentCost","newNode","h","SPEED","PathFinderVisualizer","walls","playAlgo","resetW","resetP","play","setPlay","resetWalls","setResetWalls","resetPath","setResetPath","useState","validNodes","setValidNodes","nodeS","setNodeS","setNodeF","nodes","maxRow","maxCol","currentRow","currentNode","generateGrid","playBtn","disabled","replace","innerText","changeOnPlay","bfsOrDFS","dijkstraOrAS","querySelectorAll","forEach","wall","remove","clearWalls","style","background","clearPath","id","className","map","rIndex","cIndex","onClick","placedNodeS","placedNodeF","element","length","addNode","grid","time","i","shift","pop","bfsOrDfsAlgo","timeEnd","animateAlgorithm","animatePath","changeAfterPlay","sort","a","b","dijkstraOrASAlgo","slice","visitedNodes","incrementOpacity","opacity","setTimeout","lastTime","dest","finalPath","reverse","incrementR","incrementG","r","g","Header","setAlgo","setWalls","Navbar","collapseOnSelect","expand","variant","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","changeOnAlgo","Divider","Link","addWallsBtn","changeOnAddWalls","Button","color","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.f12ec342.chunk.js","sourcesContent":["export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n    heuristic;\n    totalCost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n            this.heuristic = Infinity;\n            this.totalCost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../Node/Node';\n\n// If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* SHIFT: REMOVE AT BEGINNING | PUSH: ADD AT LAST */\n    \n// If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* POP: REMOVE AT LAST | PUSH: ADD AT LAST*/\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    const visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    console.log({nodeS, nodeF, paths});\n    while (paths.length > 0 && i <= dimension[0] * dimension[1]) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        const node = algo === 'BFS' ? paths.shift(): paths.pop();\n\n        console.log({node});\n\n        // Check the valid neighbours\n        const foundNodeF = validNeighbours(paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        \n        i++;\n    }\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited or if it's a wall\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\")) return true;\n\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n  \n    // Check if its end node\n    if (nodeF.row === y && nodeF.col === x) {\n        node.isFinish = true;\n        console.log(`%c Found`, 'color: brown');\n        \n        document.getElementById(`${x},${y}`).classList.add(\"visited\");\n        visited.push(node);\n        return true;\n    }\n\n    paths.push(node);\n\n    // Tag visited\n    document.getElementById(`${x},${y}`).classList.add(\"visited\");\n    visited.push(node);\n    return false;\n}","import Node from '../Node/Node';\n\n// Priority Queue\n    /* SHIFT: REMOVE AT BEGINNING | PUSH: ADD AT LAST */\n\nexport const dijkstraOrAS = (algo, dimension, nodeS, nodeF) => {\n\n    // Check if nodes are in the same position | Disable this when given use option\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    nodeS.cost = 0;\n    \n    // Check if AStar to add heuristic\n    if (algo === 'AStar') {\n        nodeS.heuristic = heuristic(nodeS, nodeF);\n        nodeS.totalCost = nodeS.heuristic + nodeS.cost;\n    }\n    \n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    const visited = []\n    \n    let i = 0;\n    // While there are unvisited nodes and node not found\n    // We need also to check if loop didn't reach the maximum iteration possible to prevent browser to crash\n    while (paths.length > 0 && i <= dimension[0] * dimension[1] - 2) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let node = paths.shift();  \n        console.log('Shit');\n        console.log({node});\n        \n        // If we found the node then we should get rid of the other nodes \n        if (findNodeF(node, nodeF)) {\n            console.log(`%c Found`, 'color: brown');\n            document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n            visited.push(node);\n            \n            return [visited, true];\n        }\n    \n        // Mark as visited\n        // With the DOM manipulation, I don't have to traverse the {visited} list: O(1) \n        document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n        visited.push(node);\n\n        validNeighbours(algo, paths, node, dimension, nodeF);\n\n        // Order neighbours by the cost to travel to\n        if (algo === 'AStar') {\n            paths.sort((a, b) => a.totalCost - b.totalCost);\n        } else if (algo === 'Dijkstra') {\n            paths.sort((a, b) => a.cost - b.cost);\n        } \n        //console.log({paths});\n        i++;\n    }\n\n    return [visited, false];\n}\n\n// This function calculates the heuristic\nfunction heuristic(node, nodeF) {\n\n    // Node coordinate\n    const x1 = node.col;\n    const y1 = node.row;\n    \n    // Node Finish coordinate\n    const x2 = nodeF.col;\n    const y2 = nodeF.row;\n\n    // The heuristic is the distance between the sqrt((x2-x1)² + (y2-y1)²) \n    const heuristic = Math.floor(Math.sqrt(((x2-x1) ** 2) + ((y2-y1) ** 2)));\n    //console.log(`Heuristic ${heuristic}`);\n    node.heuristic = heuristic;\n    \n    return heuristic;\n}\n\n// This function checks if a given node is the finish node\nfunction findNodeF(node, nodeF) {\n    return node.row === nodeF.row && node.col === nodeF.col;\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(algo, paths, node, [x, y - 1], nodeF);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(algo, paths, node, [x + 1, y], nodeF);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(algo, paths, node, [x, y + 1], nodeF);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(algo, paths, node, [x - 1, y], nodeF);\n        }\n    }\n}\n\n// This function checks if the node was already visited\n// The reason why I am not checking the visited list\n// is due to the runtime performance\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\") ) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(algo, paths, previousNode, coordinate, nodeF) {\n    \n    // Previous node coordinate\n    const prevX = previousNode.col;\n    const prevY = previousNode.row;\n    \n    // Node (neighbour) coordinate\n    const x = coordinate[0];\n    const y = coordinate[1];\n    \n    let node = getNode(paths, x, y);\n    console.log('Neighbour');\n    \n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    // This is equivallent to EDGE + ACCUMULATED COST \n    const newCost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n    \n    // Getting the cost of the node (the neighbour node) if already in paths. IF not returns Infinity\n    const currentCost = node.cost;\n\n    // This variable flags if node was updated or is new \n    const newNode = node.cost === Infinity;\n    \n    // Update the cost if cost is smaller than the node's atual cost\n    if (newCost <= currentCost) {\n        node.cost = newCost;\n        node.previous = previousNode;\n    }\n    \n    // If the algo is A* then we need to add the heuristic and update the total cost\n    if (algo === 'AStar') {\n        const h = heuristic(node, nodeF);\n        node.totalCost = node.cost + h;\n    }\n\n    // If we find the nodeF then we will flag it\n    if (findNodeF(node, nodeF)) {\n        node.isFinish = true;\n    }\n\n    console.log({node});\n    \n    // If its a new node, adds to the list\n    if (newNode) paths.push(node);\n    console.log({paths});\n}\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getNode(paths, x, y) {\n    // If it was already opened, returns the node\n    for (let node of paths) {\n        if (node.col === x && node.row === y) return node;\n    }\n\n    // Else, returns a new node\n    return new Node(x, y, false, false);\n}\n","import React, { useState } from 'react';\nimport './PathFinderVisualizer.css';\n\nimport Node from '../Node/Node';\n\n// Import the algorithm functions\nimport { bfsOrDfs as bfsOrDfsAlgo } from '../algorithms/bfsOrDfs';\nimport { dijkstraOrAS as dijkstraOrASAlgo } from '../algorithms/dijkstraOrAS';\n\nconst ROW = 20;\nconst COLUMN = 30;\nconst SPEED = 140; // The less the more speed\n\nexport default function PathFinderVisualizer({algo, walls, playAlgo, resetW, resetP}) {\n\n    // Decostructing the objects passed by arguments \n    const { play, setPlay } = playAlgo;\n    const { resetWalls, setResetWalls } = resetW;\n    const { resetPath, setResetPath } = resetP;\n\n    const [validNodes, setValidNodes] = useState(false);\n\n    const [nodeS, setNodeS] = useState(new Node(-1, -1, false, false));\n    const [nodeF, setNodeF] = useState(new Node(-1, -1, false, false));\n    \n    const nodes = generateGrid(ROW, COLUMN); \n    console.log({nodes});\n\n    console.log({algo});\n    console.log({walls});\n    console.log({play});\n    console.log({validNodes});\n    console.log({resetWalls});\n    console.log({resetPath});\n\n    // Check if the play button was clicked and start the chosen algorithm\n    if (play) {\n        if (validNodes) {\n\n            changeOnPlay();\n\n            switch(algo) {\n                case 'BFS':\n                    bfsOrDFS('BFS', nodes, nodeS, nodeF, setPlay);\n                    break;\n                case 'DFS':\n                    bfsOrDFS('DFS', nodes, nodeS, nodeF, setPlay);\n                    break;\n                case 'Dijkstra':\n                    dijkstraOrAS('Dijkstra', nodes, nodeS, nodeF, setPlay);\n                    break;\n                case 'AStar':\n                    dijkstraOrAS('AStar', nodes, nodeS, nodeF, setPlay);\n                    break;\n                default:\n                    console.log('Algo not found');\n            }\n        } else {\n            document.getElementById('play-btn').innerText = 'Place Nodes in the Grid';\n            console.log('Invalid');\n        }\n    }\n\n    // Check if the clear walls button was clicked\n    if (resetWalls) {\n        clearWalls(setResetWalls);\n    }\n\n    // Check if the clear path button was clicked\n    if (resetPath) {\n        clearPath(setResetPath);\n    }\n\n    return (\n        <div id = 'main'>\n            <div className = \"glass\">\n                <div className = \"guide text-dark\">\n                    <span className = \"nodeS\"></span> Start \n                    <span className = \"nodeF\"></span>  \n                    <span className = \"nodeFound\"></span> Finish | Found Node  \n                    <span className = \"nodeWall\"></span> Wall  \n                    <span className = \"algo\"></span> Algorithm \n                    <span className = \"path\"></span> Path \n                </div>\n                <div className=\"grid\">\n                    {\n                        nodes.map((row, rIndex) => {\n                            return <div key = { rIndex } className = \"grid-row\" >\n                                {\n                                row.map((node, cIndex) => {\n                                    // const isStart = (cIndex === START_X && rIndex === START_Y);\n                                    // const isFinish = (cIndex === FINISH_X && rIndex === FINISH_Y);\n                                    //const extraClassName = isStart ? ' node-start visited': isFinish ? ' node-finish' : '';\n                                    return ( \n                                        <div onClick = {() => addNode([cIndex, rIndex], [nodeS, setNodeS], [nodeF, setNodeF], walls, setValidNodes) } \n                                            id = {`${cIndex},${rIndex}`} \n                                            className = {`node`} key = {cIndex}>\n                                        </div>\n                                    )\n                                })\n                                }\n                            </div>\n                        })\n                    }\n                </div>\n            </div>\n        </div>\n    )\n}\n\nfunction addNode(coordinate, placedNodeS, placedNodeF, walls, setValidNodes) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    const nodeS = placedNodeS[0];\n    const nodeF = placedNodeF[0];\n\n    const setNodeS = placedNodeS[1];\n    const setNodeF = placedNodeF[1];\n\n    const element = document.getElementById(`${x},${y}`);\n\n    // The user must first clean the path and only then remove/add nodes \n    if (document.getElementById('clearPath-btn').disabled) {\n        // TOGGLE nodeS\n        if (element.classList.contains('node-start')) {\n            \n            element.classList.remove('node-start', 'visited');\n            setNodeS(new Node(-1, -1, false, false));\n            return ;\n        } \n    \n        // TOGGLE nodeF\n        if (element.classList.contains('node-finish')) {\n        \n            element.classList.remove('node-finish');\n            setNodeF(new Node(-1, -1, false, false));\n            setValidNodes(false);\n            return ;\n        } \n    \n        //Check if we have nodeS and nodeF placed. If yes, then we add walls\n        if (!nodeS.isStart) {\n    \n            element.classList.add('node-start', 'visited');\n            setNodeS(new Node(x, y, true, false));\n            return ;\n        }\n        \n        if (!nodeF.isFinish) {\n            \n            element.classList.add('node-finish');\n            setNodeF(new Node(x, y, false, true));\n            setValidNodes(true);\n            return ;\n         }\n        \n        if (walls) {\n    \n            const walls = document.querySelectorAll('.wall');\n            if (walls.length >= 0 ) {\n                document.getElementById('clearWalls-btn').disabled = false; // =0 because of cycle\n            } else {\n                document.getElementById('clearWalls-btn').disabled = true;\n            }\n            // Toggle wall\n            if (element.classList.contains('wall')) {\n                element.classList.remove('wall');\n                return ;\n            } \n            element.classList.add('wall');\n        }\n        \n    }\n\n    // document.getElementById('collasible-nav-dropdown').innerText = 'Choose Algorithm';\n    // document.getElementById('collasible-nav-dropdown').classList.remove('disabled');\n    \n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = `${col},${row}`;\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode);\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function handles the user click when choosing BFS or DFS\nfunction bfsOrDFS(algo, grid, nodeS, nodeF, setPlay) {\n    // DIMENSION: 0 = ROW | 1 = COLUMN\n    const dimension = [grid.length, grid[0].length];\n\n    console.time(\"runtime\");\n\n    // This variable holds the result of the BFS algorithm visisted nodes\n    // [0] = visited nodes [1] = found node\n    const nodes = bfsOrDfsAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    \n    console.timeEnd(\"runtime\");\n    console.log({visited});\n        \n    // With slice(0) we are including nodeS\n    animateAlgorithm(visited);\n    \n    if (nodes[1]) {\n        \n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The second args referes to the last node a.k.a nodeF\n        // The third args referes to the setter of the play useState\n        animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay); \n   } else {\n       changeAfterPlay(setPlay);\n   }\n}\n\n// This function handles the user click when choosing Dijsktra\nfunction dijkstraOrAS(algo, grid, nodeS, nodeF, setPlay) {\n    const dimension = [grid.length, grid[0].length];\n\n    console.time('runtime');\n    \n    const nodes = dijkstraOrASAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    \n    console.timeEnd('runtime');\n    console.log({visited});\n\n    // With slice(0) we are including nodeS\n    animateAlgorithm(visited.slice(1));\n    \n    if (nodes[1]) {\n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The second args referes to the last node a.k.a nodeF\n        // The third args referes to the setter of the play useState\n        animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay);\n    } else {\n        changeAfterPlay(setPlay);\n    }\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n\n    const incrementOpacity = (0.7 / visitedNodes.length);  \n    let opacity = 0.3\n\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n\n        // With setTimeout, we change the color of each visited node with SPEED time between them\n        setTimeout(() => {\n            if (!node.isFinish) {\n                document.getElementById(`${node.col},${node.row}`).style.background = `rgba(109, 93, 254, ${opacity})`;\n                opacity += incrementOpacity\n            \n            } else {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"red\";\n            }\n        } , SPEED * i);\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(lastTime, nodeF, setPlay) {\n\n    // Get the last node a.k.a last visited node\n    let dest = nodeF\n    console.log({dest});\n    let finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    finalPath.reverse();\n    console.log({finalPath});\n        \n    const incrementR = Math.floor(228 / finalPath.length); \n    const incrementG = Math.floor((255 - 128) / finalPath.length); \n    let r = 0;\n    let g = 128;\n    // The last node is the nodeS, so we wont count it\n    for (let i = 1; i <= finalPath.length; i++) {\n\n        setTimeout(() => {\n            const node = finalPath[i];\n\n            if (i === finalPath.length) {\n                changeAfterPlay(setPlay);\n            } else if (i === finalPath.length - 1) {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"yellow\";\n            } else {\n                r += incrementR;\n                g += incrementG;\n                document.getElementById(`${node.col},${node.row}`).style.background = `rgb(${r}, ${g}, 0)`;\n            }\n\n        // time of the last animation + time for the next animations\n        } , lastTime + (SPEED * (i - 1)));\n    }\n}\n\n// This function clears the walls\nfunction clearWalls(setResetWalls) {\n    \n    setResetWalls(false);\n\n    // Reset any stylization\n    const walls = document.querySelectorAll('.wall');\n    walls.forEach((wall) => {\n        wall.classList.remove('wall');\n    });\n\n    document.getElementById('clearWalls-btn').disabled = true;\n}\n\n// This function clears the path\nfunction clearPath(setResetPath) {\n    \n    setResetPath(false);\n\n    // Reset any stylization\n    const nodes = document.querySelectorAll('.visited');\n    nodes.forEach((node) => {\n        if (!node.classList.contains('node-start')) node.classList.remove('visited');\n        node.style.background = '';\n    });\n\n    // Set the clear path button\n    document.getElementById('clearPath-btn').disabled = true;\n    document.getElementById('play-btn').disabled = false;\n    document.getElementById('addWalls-btn').disabled = false;\n}\n\nfunction changeOnPlay() {\n    \n    const playBtn = document.getElementById('play-btn'); \n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n    \n    // Change add walls button state\n    document.getElementById('addWalls-btn').disabled = true;\n    \n    // Change play button state\n    playBtn.classList.replace('btn-success', 'btn-danger');\n    playBtn.innerText = 'Searching for path...';\n    playBtn.disabled = true;\n    \n    // Change clear walls button state\n    document.getElementById('clearWalls-btn').disabled = true;\n    // Change clear path button state\n    document.getElementById('clearPath-btn').disabled = true;\n}\n\n// This functions change some elements state\nfunction changeAfterPlay(setPlay) {\n    \n    setPlay(false);\n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.remove('disabled');;\n\n    // Change play button state\n    document.getElementById('play-btn').classList.replace('btn-danger', 'btn-success');\n    document.getElementById('play-btn').innerText = 'Play';\n\n    // Change clear path state\n    document.getElementById('clearPath-btn').disabled = false;\n\n    const walls = document.querySelectorAll('.wall');\n    if (walls.length > 0 ) document.getElementById('clearWalls-btn').disabled = false;\n    \n} ","import React from 'react';\nimport './Header.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\n\nexport default function Header({ setAlgo, setWalls, setPlay, setResetWalls, setResetPath }) {\n\n    return (\n        <Navbar id=\"navbar\" collapseOnSelect expand=\"sm\" variant=\"dark\">\n            <Navbar.Brand>PathFinder</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n            <Nav className=\"mr-auto\">\n                <NavDropdown id=\"collasible-nav-dropdown\" className=\"btn\" title=\"Choose Algorithm\"  variant=\"dark\">\n                    <NavDropdown.Item onClick={() => changeOnAlgo('BFS', setAlgo)}>BFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('DFS', setAlgo)} disabled>DFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('Dijkstra', setAlgo)}>Dijkstra</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('AStar', setAlgo)}>A*</NavDropdown.Item>\n                </NavDropdown>\n                <Nav.Link onClick={() => changeOnAddWalls(setWalls)}><Button id='addWalls-btn' variant=\"info\" disabled>Add Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => changeOnPlay(setPlay)}><Button id='play-btn' variant=\"success\" disabled>Play</Button></Nav.Link>\n            </Nav>\n            <Nav>\n                <Nav.Link onClick = {() => resetWalls(setResetWalls)}><Button id='clearWalls-btn' variant=\"secondary\" disabled>Clear Walls</Button></Nav.Link>\n                <Nav.Link onClick = {() => resetPath(setResetPath)}><Button id='clearPath-btn' variant=\"danger\" disabled>Clear Path</Button></Nav.Link>\n            </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}\n\n/* These functions change some elements state */\nfunction changeOnAlgo(algo, setAlgo) {\n\n    setAlgo(algo);\n\n    // Manipulate the choose algorithm title\n    document.getElementById('collasible-nav-dropdown').innerText = algo;\n    document.getElementById('collasible-nav-dropdown').style.color = 'lightgreen';\n    \n    // Manipulate the play btn\n    // Only activate play and add walls btn if clear path is disabled. \n    // If it is enable it means that the user did not clear the path yet, hence not activating the play button\n    if (document.getElementById('clearPath-btn').disabled) {\n        document.getElementById('play-btn').disabled = false;\n        document.getElementById('addWalls-btn').disabled = false;\n    }\n}\n\nfunction changeOnAddWalls(setWalls) {\n    // Change add walls button state\n    const addWallsBtn = document.getElementById('addWalls-btn');\n\n    // Toggle\n    // ADD WALLS\n    if (addWallsBtn.classList.contains('btn-info')) {\n\n        setWalls(true);\n        \n        addWallsBtn.classList.replace('btn-info', 'btn-warning');\n        addWallsBtn.innerText = 'Enough of Walls';\n        \n        // Change choose algo dropdown state\n        document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n        \n        // Change play button state\n        document.getElementById('play-btn').disabled = true;\n\n    // STOP ADDING WALLS\n    } else if (addWallsBtn.classList.contains('btn-warning')) {\n        \n        setWalls(false);\n\n        addWallsBtn.classList.replace('btn-warning', 'btn-info');\n        addWallsBtn.innerText = 'Add Walls';\n\n        // Change choose algo dropdown state\n        document.getElementById('collasible-nav-dropdown').classList.remove('disabled');\n\n        // Change play button state\n        document.getElementById('play-btn').disabled = false;\n    \n    }\n}\n\nfunction changeOnPlay(setPlay) {\n    setPlay(true);\n}\n\n// This function updates the resetPath state\nfunction resetWalls(setResetWalls) {\n    setResetWalls(true);\n}\n\n// This function updates the resetPath state\nfunction resetPath(setResetPath) {\n    setResetPath(true);\n}","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\nimport Header from './Header/Header';\nimport React, { useState } from 'react';\n\nexport default function App() {\n  \n  const [algo, setAlgo] = useState('');\n  const [walls, setWalls] = useState(false);\n  const [play, setPlay] = useState(false);\n  const [resetWalls, setResetWalls] = useState(false);\n  const [resetPath, setResetPath] = useState(false);\n\n  return (\n    <div className=\"App\">\n      <Header \n        setAlgo = { setAlgo } setWalls = { setWalls } \n        setPlay = { setPlay } setResetWalls = { setResetWalls } setResetPath = { setResetPath }></Header>\n      <PathFinderVisualizer \n        algo = { algo } walls = { walls }\n        playAlgo = { {play, setPlay} } resetW = { {resetWalls, setResetWalls} } resetP = { {resetPath, setResetPath} }>\n       </PathFinderVisualizer>\n    </div>\n  );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}