{"version":3,"sources":["PathFinderVisualizer/Node/Node.jsx","PathFinderVisualizer/Node/NodeObj.js","algorithms/bfsOrDfs.js","algorithms/dijkstra.js","algorithms/aStar.js","PathFinderVisualizer/PathFinderVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","isStart","isFinish","coordinates","extraClassName","id","className","React","Component","NodeObj","col","row","previous","cost","Infinity","bfsOrDfs","algo","dimension","nodeS","nodeF","paths","visited","i","length","console","log","node","shift","pop","validNeighbours","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","add","previousNode","push","unshift","findNodeF","prevX","prevY","Math","abs","visitedCost","getVisitedCost","realCost","min","PathFinderVisualizer","nodes","maxRow","maxCol","start","finish","currentRow","currentNode","generateGrid","setState","querySelectorAll","forEach","style","background","grid","time","timeEnd","animateAlgorithm","animatePath","sort","a","b","dijkstraAlgo","map","rIndex","nodeIndex","onClick","bfs","dfs","dijsktra","aStar","visitedNodes","setTimeout","lastTime","dest","finalPath","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.851e0161.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default class Node extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n\n    render() {\n        // Getting the attributes (Passed in PathfinderVisualizer.jsx render() <Node [atributtes]>)\n        const { isStart, isFinish, coordinates } = this.props;\n        const extraClassName = isStart ? 'node-start visited': isFinish ? 'node-finish' : '';\n\n        return <div id={`${ coordinates }`} className={`node ${ extraClassName }`}></div>;\n    }\n\n}","export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../PathFinderVisualizer/Node/NodeObj'\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS[\"col\"] === nodeF[\"col\"] && \n            nodeS[\"row\"] === nodeF[\"row\"]) {\n                return [[nodeS], false];\n    }\n\n    // If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* PUSH: ADD AT LAST | POP: REMOVE AT LAST*/\n    \n    // If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\n    // This variable holds the open nodes (coordinate) [x, y]\n    const paths = [nodeS];\n    let visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    while (paths.length > 0) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        let node = algo === 'BFS' ? paths.shift(): paths.pop();\n        console.log({node});\n        \n        // Check the valid neighbours\n        let foundNodeF = validNeighbours(algo, paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        i++;\n    }\n\n    console.log({visited})\n    console.log({paths})\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node[\"col\"];\n    const y = node[\"row\"];\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\")) return true;\n\n    // If not, adds it\n    node.classList.add(\"visited\");\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(algo, paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n    // If BFS, adds the node to the end of the queue || end of the array\n    if (algo === 'BFS') {\n        paths.push(node);\n        visited.push(node);\n\n    // If DFS, adds the node to the top of the stack || start of the array\n    } else {\n        paths.unshift(node);\n        visited.push(node);\n    }\n\n    // Check if its end node\n    if (nodeF[\"row\"] === y && nodeF[\"col\"] === x) {\n        console.log({nodeF, y, x})\n        console.log(`%c Found`, 'color: brown');\n        return true;\n    }\n    \n    return false;\n}","export const dijkstraAlgo = (dimension, nodeS, nodeF) => {\n\n\n    // Priority Queue\n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\n    nodeS.cost = 0;\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    \n    let i = 0;\n    while (paths.length > 0) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let { node } = paths.unshift();\n        \n        if (findNodeF(node, nodeF)) {\n            nodeF.previous = node;\n            return ;\n        }\n        \n        // Mark as visited\n        document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).classList.add('visited');\n        validNeighbours(paths, node, dimension);\n\n        // Order neighbours by the cost to travel to\n        paths.sort((a, b) => a.cost - b.cost); \n        \n}\n}\n\nfunction findNodeF(node, nodeF) {\n    return node[\"row\"] === nodeF[\"row\"] && node[\"col\"] === nodeF[\"col\"] \n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(paths, node, dimension) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node[\"col\"];\n    const y = node[\"row\"];\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(paths, node, [x, y - 1]);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(paths, node, [x + 1, y]);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(paths, node, [x, y + 1]);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(paths, node, [x - 1, y]);\n        }\n    }\n}\n\n// This function checks if the node was already visited\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\")) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(paths, previousNode, coordinate) {\n\n    const prevX = previousNode[\"col\"];\n    const prevY = previousNode[\"row\"];\n    \n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    const cost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n\n    const visitedCost = getVisitedCost(paths, x, y);\n\n    // Update the cost if cost is smaller than the node's atual cost\n    const realCost = Math.min(cost, visitedCost);\n\n    let node = new Node(x, y, false, false);\n    node.cost = realCost;\n    node.previous = previousNode;\n\n    paths.push(node);\n}\n\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getVisitedCost(paths, x, y) {\n    for (let node in paths) {\n        if (node[\"col\"] === x && node[\"row\"] === y) return node.cost;\n    }\n    return Infinity;\n}","export const aStarAlgo = (dimension, nodeS, nodeF) => {\n    // def a_star(graph, start, goal):\n    // q = [(start, [],0,10, 10)]\n    // print('q inicial ', q)\n    // done = []\n    // while q:\n    //     print(q)\n    //     (vertex, path, custo, heuristic, total) = q.pop(0)\n    //     if vertex == goal:\n    //         print('Custo total ', custo)\n    //         yield path + [vertex]\n    //     done.append(vertex)\n    //     for next in graph[vertex] - set(path):\n    //         if next[0] not in done:\n    //             custo =  next[1]\n    //             heuristic = next[2]\n    //             total = custo + heuristic\n    //             #custo  = custo + next[1]\n    //         # sorted(path + [next], key = lambda x: x[1])\n    //             q.append((next[0], path + [vertex], custo, heuristic, total))\n    //             custo = custo + next[1]\n    //             q.sort(key=lambda x:x[4])\n} ","import React from 'react';\nimport './PathFinderVisualizer.css';\nimport Node from './Node/Node';\nimport NodeObj from './Node/NodeObj'\n// Import the algorithm functions\nimport { bfsOrDfs } from '../algorithms/bfsOrDfs';\nimport { dijkstraAlgo } from '../algorithms/dijkstra';\nimport { aStarAlgo } from '../algorithms/aStar';\n\nconst ROW = 20;\nconst COLUMN = 30;\n\n// Has to be less than columns\nconst START_X = 5;\n// Has to be less than row\nconst START_Y = 5;\n\n// Has to be less than columns\nconst FINISH_X = 8;\n// Has to be less than row\nconst FINISH_Y = 8;\n\nconst SPEED = 50; // The less the more\n\nexport default class PathFinderVisualizer extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            nodes: []\n        }\n    }\n\n    componentDidMount() {\n        // Generate a grid with args1 rows and args2 columns \n        // and starting node in **coordinates** args3 \n        // and ending node in **coordinates** args4 \n        let nodes = generateGrid(ROW, COLUMN, [START_X, START_Y],[FINISH_X, FINISH_Y]);\n        this.setState({nodes});\n    }\n\n    // This function resets the grid\n    resetGrid() {\n        // Reset any stylization\n        let nodes = document.querySelectorAll('.node'); \n        nodes.forEach((node) => {\n            if (node.style.background !== '') node.style.background = '';\n        });\n\n        // Not working properly\n        // this.componentDidMount();\n    }\n\n    // This function handles the user click when choosing BFS\n    bfs(grid, nodeS, nodeF) {\n        // DIMENSION: 0 = ROW | 1 = COLUMN\n        const dimension = [grid.length, grid[0].length];\n\n        console.time(\"bfs\");\n        // This variable holds the result of the BFS algorithm visisted nodes\n        // [0] = visited nodes [1] = found node\n        const nodes = bfsOrDfs('BFS', dimension, nodeS, nodeF);\n        console.timeEnd(\"bfs\");\n        \n        animateAlgorithm(nodes[0]);\n        \n        if (nodes[1]) animatePath(nodes[0]); \n    }\n    \n    \n    // This function handles the user click when choosing DFS\n    dfs(grid, nodeS, nodeF) {\n        // DIMENSION: 0 = ROW | 1 = COLUMN\n        const dimension = [grid.length, grid[0].length];\n        \n        console.time(\"dfs\");\n        // This variable holds the result of the DFS algorithm visisted nodes\n        const nodes = bfsOrDfs('DFS', dimension, nodeS, nodeF);\n        console.timeEnd(\"dfs\");\n\n        animateAlgorithm(nodes[0]);\n        \n        if (nodes[1]) animatePath(nodes[0]); \n    }\n    \n    // This function handles the user click when choosing Dijsktra\n    dijsktra(grid, nodeS, nodeF) {\n        const dimension = [grid.length, grid[0].length];\n\n        dijkstraAlgo(dimension, nodeS, nodeF);\n        console.log({nodeF});\n    }\n    \n    // This function handles the user click when choosing A*\n    aStar(grid, nodeS, nodeF) {\n        const dimension = [grid.length, grid[0].length];\n        aStarAlgo(dimension, nodeS, nodeF);\n    }\n\n    render() {\n        // Getting the nodes/grid\n        const {nodes} = this.state;\n        let nodeS;\n        let nodeF;\n        console.log({nodes})\n        return (\n           <div className=\"grid\">\n               {\n                  nodes.map((row, rIndex) => {\n                      return <div key={rIndex} className=\"grid-row\">\n                        {\n                          row.map((node, nodeIndex) => {\n                            const { isStart, isFinish, col, row} = node;\n                            if (isStart) nodeS = node;\n                            if (isFinish) nodeF = node;\n                            return <Node  \n                                coordinates={`${col},${row}`} key={nodeIndex}\n                                isStart = {isStart} isFinish = {isFinish}\n                            ></Node>\n                          })\n                        }\n                        </div>\n                    })\n               }\n               <div className=\"buttons\">\n                   <button onClick={() => this.bfs(nodes, nodeS, nodeF)}>BFS</button>\n                   <button onClick={() => this.dfs(nodes, nodeS, nodeF)}>DFS</button>\n                   <button onClick={() => this.dijsktra(nodes, nodeS, nodeF)}>Dijkstra</button>\n                   <button onClick={() => this.aStar(nodes, nodeS, nodeF)}>A*</button>\n                   <button className=\"resetGrid\" /*onClick={() => this.resetGrid()*} */>Clear path</button>\n               </div>\n           </div>\n        )\n    }\n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol, start, finish) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = new NodeObj(\n                    col,\n                    row,\n                    row === start[1] && col === start[0],\n                    row === finish[1] && col === finish[0]\n                )\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode)\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n        if (i !== visitedNodes.length - 1) {\n            // With setTimeout, we change the color of each visited node with 145ms  between them\n            setTimeout(() => {\n                document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"lightblue\";\n            } , SPEED * i);\n        }\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(nodes) {\n\n    let lastTime = nodes.length\n\n    // Get the last node a.k.a last visited node\n    let dest = nodes[nodes.length - 1]\n    console.log({dest});\n    const finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    console.log({finalPath});\n        \n    // The last node is the nodeS, so we wont count it\n    for (let i = finalPath.length - 2; i >= 0; i--) {\n        setTimeout(() => {\n            const node = finalPath[i]\n            if (i === 0) {\n                document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"yellow\";\n            } else {\n                document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"purple\";\n            }\n           // time of the last animation + time for the next animations\n        } , (lastTime * SPEED + 50) + ( SPEED * (finalPath.length - i) ));\n    }\n}\n","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\n// import Header from './Header/Header';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {/* <Header></Header> */}\n      <PathFinderVisualizer></PathFinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}