{"version":3,"sources":["Node/Node.jsx","Node/NodeObj.js","algorithms/bfsOrDfs.js","algorithms/dijkstraOrAS.js","PathFinderVisualizer/PathFinderVisualizer.jsx","Header/Header.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","isStart","isFinish","coordinates","extraClassName","id","className","React","Component","NodeObj","col","row","previous","cost","Infinity","heuristic","totalCost","validNeighbours","algo","paths","visited","node","dimension","nodeF","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","add","previousNode","push","unshift","console","log","x1","y1","x2","y2","Math","floor","sqrt","findNodeF","prevX","prevY","getNode","newCost","abs","currentCost","updatedCost","min","h","PathFinderVisualizer","nodeS","myAlgo","play","reset","useState","generateGrid","nodes","setNodes","map","rIndex","nodeIndex","onClick","bfsOrDFS","dijkstraOrAS","querySelectorAll","forEach","style","background","remove","resetGrid","maxRow","maxCol","start","finish","currentRow","currentNode","grid","length","time","i","shift","pop","bfsOrDfsAlgo","timeEnd","animateAlgorithm","animatePath","sort","a","b","dijkstraOrASAlgo","slice","visitedNodes","setTimeout","lastTime","dest","finalPath","Header","setAlgo","setPlay","setResetPath","Navbar","collapseOnSelect","expand","variant","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","disabled","Item","chooseAlgo","Divider","Link","Button","replace","innerText","playAlgo","resetPath","color","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.727f5f33.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default class Node extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n\n    render() {\n        // Getting the attributes (Passed in PathfinderVisualizer.jsx render() <Node [atributtes]>)\n        const { isStart, isFinish, coordinates } = this.props;\n        const extraClassName = isStart ? 'node-start visited': isFinish ? 'node-finish' : '';\n\n        return <div id={`${ coordinates }`} className={`node ${ extraClassName }`}></div>;\n    }\n\n}","export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n    heuristic;\n    totalCost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n            this.heuristic = Infinity;\n            this.totalCost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../Node/NodeObj';\n\n// If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* PUSH: ADD AT LAST | POP: REMOVE AT LAST*/\n    \n    // If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    while (paths.length > 0 && i <= dimension[0] * dimension[1]) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        let node = algo === 'BFS' ? paths.shift(): paths.pop();\n        console.log({node});\n        \n        // Check the valid neighbours\n        let foundNodeF = validNeighbours(algo, paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        \n        i++;\n    }\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited or if it's a wall\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\")) return true;\n\n    // If not, adds it\n    node.classList.add(\"visited\");\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(algo, paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n    // If BFS, adds the node to the end of the queue || end of the array\n    if (algo === 'BFS') {\n        paths.push(node);\n        visited.push(node);\n    // If DFS, adds the node to the top of the stack || start of the array\n    } else if (algo === 'DFS') {\n        paths.unshift(node);\n        visited.push(node);\n    }\n\n    // Check if its end node\n    if (nodeF.row === y && nodeF.col === x) {\n        node.isFinish = true;\n        console.log(`%c Found`, 'color: brown');\n        return true;\n    }\n    \n    return false;\n}","import Node from '../Node/NodeObj';\n\n// Priority Queue\n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const dijkstraOrAS = (algo, dimension, nodeS, nodeF) => {\n\n    // Check if nodes are in the same position | Disable this when given use option\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    nodeS.cost = 0;\n    \n    // Check if AStar to add heuristic\n    if (algo === 'AStar') {\n        nodeS.heuristic = heuristic(nodeS, nodeF);\n        nodeS.totalCost = nodeS.heuristic + nodeS.cost;\n    }\n    \n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n    \n    let i = 0;\n    // While there are unvisited nodes and node not found\n    // We need also to check if loop didn't reach the maximum iteration possible to prevent browser to crash\n    while (paths.length > 0 && i <= dimension[0] * dimension[1]) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let node = paths.shift();  \n        console.log('Shit');\n        console.log({node});\n        \n        // If we found the node then we should get rid of the other nodes \n        if (findNodeF(node, nodeF)) {\n            console.log(`%c Found`, 'color: brown');\n            visited.push(node);\n            \n            return [visited, true];\n        }\n    \n        // Mark as visited\n        // With the DOM manipulation, I don't have to traverse the {visited} list: O(1) \n        document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n        visited.push(node);\n\n        validNeighbours(algo, paths, node, dimension, nodeF);\n\n        // Order neighbours by the cost to travel to\n        if (algo === 'AStar') {\n            paths.sort((a, b) => a.totalCost - b.totalCost);\n        } else if (algo === 'Dijkstra') {\n            paths.sort((a, b) => a.cost - b.cost);\n        } \n        //console.log({paths});\n        i++;\n    }\n\n    return [visited, false];\n}\n\n// This function calculates the heuristic\nfunction heuristic(node, nodeF) {\n\n    // Node coordinate\n    const x1 = node.col;\n    const y1 = node.row;\n    \n    // Node Finish coordinate\n    const x2 = nodeF.col;\n    const y2 = nodeF.row;\n\n    // The heuristic is the distance between the sqrt((x2-x1)² + (y2-y1)²) \n    const heuristic = Math.floor(Math.sqrt(((x2-x1) ** 2) + ((y2-y1) ** 2)));\n    //console.log(`Heuristic ${heuristic}`);\n    node.heuristic = heuristic;\n    \n    return heuristic;\n}\n\n// This function checks if a given node is the finish node\nfunction findNodeF(node, nodeF) {\n    return node.row === nodeF.row && node.col === nodeF.col;\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(algo, paths, node, [x, y - 1], nodeF);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(algo, paths, node, [x + 1, y], nodeF);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(algo, paths, node, [x, y + 1], nodeF);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(algo, paths, node, [x - 1, y], nodeF);\n        }\n    }\n}\n\n// This function checks if the node was already visited\n// The reason why I am not checking the visited list\n// is due to the runtime performance\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\")) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(algo, paths, previousNode, coordinate, nodeF) {\n    \n    // Previous node coordinate\n    const prevX = previousNode.col;\n    const prevY = previousNode.row;\n    \n    // Node (neighbour) coordinate\n    const x = coordinate[0];\n    const y = coordinate[1];\n    \n    let node = getNode(paths, x, y);\n    console.log('Neighbour');\n    \n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    // This is equivallent to EDGE + ACCUMULATED COST \n    const newCost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n    \n    // Getting the cost of the node (the neighbour node) if already in paths. IF not returns Infinity\n    const currentCost = node.cost;\n    \n    // Update the cost if cost is smaller than the node's atual cost\n    const updatedCost = Math.min(newCost, currentCost);\n    \n    node.cost = updatedCost;\n    node.previous = previousNode;\n\n    // If the algo is A* then we need to add the heuristic and update the total cost\n    if (algo === 'AStar') {\n        const h = heuristic(node, nodeF);\n        node.totalCost = node.cost + h;\n    }\n\n    // If we find the nodeF then we will flag it\n    if (findNodeF(node, nodeF)) {\n        node.isFinish = true;\n    }\n\n    console.log({node});\n    \n    paths.push(node);\n    console.log({paths});\n}\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getNode(paths, x, y) {\n    // If it was already opened, returns the node\n    for (let node of paths) {\n        if (node.col === x && node.row === y) return node;\n    }\n\n    // Else, returns a new node\n    return new Node(x, y, false, false);\n}\n","import React, { useState } from 'react';\nimport './PathFinderVisualizer.css';\n\nimport Node from '../Node/Node';\nimport NodeObj from '../Node/NodeObj';\n\n// Import the algorithm functions\nimport { bfsOrDfs as bfsOrDfsAlgo } from '../algorithms/bfsOrDfs';\nimport { dijkstraOrAS as dijkstraOrASAlgo } from '../algorithms/dijkstraOrAS';\n\nconst ROW = 20;\nconst COLUMN = 30;\n\n// Has to be less than columns\nconst START_X = 5;\n// Has to be less than row\nconst START_Y = 5;\n\n// Has to be less than columns\nconst FINISH_X = 9;\n// Has to be less than row\nconst FINISH_Y = 7;\n\nconst SPEED = 60; // The less the more speed\n\nexport default function PathFinderVisualizer({myAlgo, play, reset}) {\n    let nodeS;\n    let nodeF;\n    \n    const [nodes, setNodes] = useState(generateGrid(ROW, COLUMN, [START_X, START_Y], [FINISH_X, FINISH_Y])); \n    console.log({nodes});\n\n    console.log({myAlgo});\n    console.log({play});\n    console.log({reset});\n\n    // if (play) {\n    //     switch(myAlgo) {\n    //         case 'BFS': \n    //             bfsOrDFS('BFS', nodes, nodeS, nodeF);\n    //             break;\n    //         case 'DFS': \n    //             bfsOrDFS('DFS', nodes, nodeS, nodeF);\n    //             break;\n    //         case 'Dijkstra': \n    //             dijkstraOrAS('Dijkstra', nodes, nodeS, nodeF);\n    //             break;\n    //         case 'AStar': \n    //             dijkstraOrAS('AStar', nodes, nodeS, nodeF);\n    //             break;\n    //         default:\n    //             console.log('Algo not found');\n    //     }\n    // }\n\n    return (\n        <div className= \"container-fluid\">\n            <div className=\"grid\">\n                {\n                    nodes.map((row, rIndex) => {\n                        return <div key={ rIndex } className=\"grid-row\" >\n                            {\n                            row.map((node, nodeIndex) => {\n                                const { isStart, isFinish, col, row } = node;\n                                if (isStart) nodeS = node;\n                                if (isFinish) nodeF = node;\n                                return <Node\n                                    coordinates={`${col},${row}`} key={ nodeIndex }\n                                    isStart = { isStart } isFinish = { isFinish }\n                                ></Node>\n                            })\n                            }\n                        </div>\n                    })\n                }\n                <div className=\"buttons\">\n                    <button onClick={() => bfsOrDFS('BFS', nodes, nodeS, nodeF)}>BFS</button>\n                    <button onClick={() => bfsOrDFS('DFS', nodes, nodeS, nodeF)}>DFS</button>\n                    <button onClick={() => dijkstraOrAS('Dijkstra', nodes, nodeS, nodeF)}>Dijkstra</button>\n                    <button onClick={() => dijkstraOrAS('AStar', nodes, nodeS, nodeF)}>A*</button>\n                    <button onClick={() => resetGrid(setNodes)}>Clear path | Reload page</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol, start, finish) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = new NodeObj(\n                    col,\n                    row,\n                    row === start[1] && col === start[0],\n                    row === finish[1] && col === finish[0]\n                );\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode);\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function handles the user click when choosing BFS or DFS\nfunction bfsOrDFS(algo, grid, nodeS, nodeF) {\n    // DIMENSION: 0 = ROW | 1 = COLUMN\n    const dimension = [grid.length, grid[0].length];\n\n    console.time(\"runtime\");\n\n    // This variable holds the result of the BFS algorithm visisted nodes\n    // [0] = visited nodes [1] = found node\n    const nodes = bfsOrDfsAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    console.log({visited});\n        \n    console.timeEnd(\"runtime\");\n        \n   animateAlgorithm(visited);\n   \n   // The first args refers to the time that the animateAlgorithm finished + 50ms\n   // The seconde args return the last node a.k.a nodeF\n   if (nodes[1]) animatePath(SPEED * visited.length + 75, visited[visited.length - 1]); \n}\n\n// This function handles the user click when choosing Dijsktra\nfunction dijkstraOrAS(algo, grid, nodeS, nodeF) {\n    const dimension = [grid.length, grid[0].length];\n\n    console.time('runtime');\n    \n    const nodes = dijkstraOrASAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    console.log({visited});\n\n    console.timeEnd('runtime');\n\n    // With slice(0) we are including nodeS\n    animateAlgorithm(visited.slice(1));\n\n    // The first args refers to the time that the animateAlgorithm finished + 50ms\n    // The seconde args return the last node a.k.a nodeF\n    if (nodes[1]) animatePath(SPEED * visited.length + 75, visited[visited.length - 1]);\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n        if (i !== visitedNodes.length - 1) {\n            // With setTimeout, we change the color of each visited node with 145ms  between them\n            setTimeout(() => {\n                if (!node.isFinish) {\n                    document.getElementById(`${node.col},${node.row}`).style.background = \"lightblue\";\n                } else {\n                    document.getElementById(`${node.col},${node.row}`).style.background = \"red\";\n                }\n            } , SPEED * i);\n        }\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(lastTime, nodeF) {\n\n    // Get the last node a.k.a last visited node\n    let dest = nodeF\n    console.log({dest});\n    const finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    console.log({finalPath});\n        \n    // The last node is the nodeS, so we wont count it\n    for (let i = finalPath.length - 2; i >= 0; i--) {\n        setTimeout(() => {\n            const node = finalPath[i]\n            if (node.isFinish) {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"yellow\";\n            } else {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"purple\";\n            }\n           // time of the last animation + time for the next animations\n        } , lastTime + ( SPEED * (finalPath.length - i) ));\n    }\n}\n\n// This function resets the grid\nfunction resetGrid(setNodes) {\n    // Reset any stylization\n    let nodes = document.querySelectorAll('.node');\n    nodes.forEach((node) => {\n        if (node.style.background !== '') node.style.background = '';\n        if (node.classList.contains('visited') && !node.classList.contains('node-start')) node.classList.remove('visited');\n    });\n\n    setNodes(generateGrid(ROW, COLUMN, [START_X, START_Y], [FINISH_X, FINISH_Y]))\n\n}","import React from 'react';\nimport './Header.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\n\nexport default function Header({ setAlgo, setPlay, setResetPath }) {\n\n    return (\n        <Navbar id=\"navbar\" collapseOnSelect expand=\"sm\" variant=\"dark\">\n            <Navbar.Brand>PathFinder</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n            <Nav className=\"mr-auto\">\n                <NavDropdown id=\"collasible-nav-dropdown\" className=\"btn\" title=\"Choose Algorithm\"  variant=\"dark\" disabled>\n                    <NavDropdown.Item onClick={() => chooseAlgo('BFS', setAlgo)}>BFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => chooseAlgo('DFS', setAlgo)}>DFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => chooseAlgo('Dijkstra', setAlgo)}>Dijkstra</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => chooseAlgo('AStar', setAlgo)}>A*</NavDropdown.Item>\n                </NavDropdown>\n                <Nav.Link><Button variant=\"info\" disabled>Add Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => playAlgo(setPlay)}><Button id='play-btn' variant=\"success\" disabled>Play</Button></Nav.Link>\n            </Nav>\n            <Nav>\n                <Nav.Link><Button variant=\"warning\" disabled>Clear Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => resetPath(setResetPath)}><Button variant=\"danger\" disabled>Clear Path</Button></Nav.Link>\n            </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}\n\n// This function updates the algorithm state\nfunction chooseAlgo(algo, setAlgo) {\n    setAlgo(algo);\n    document.getElementById('collasible-nav-dropdown').innerText = algo;\n    document.getElementById('collasible-nav-dropdown').style.color = 'lightgreen';\n    document.getElementById('play-btn').disabled = false;\n}\n\n// This function updates the play state\nfunction playAlgo(setPlay) {\n    setPlay(true);\n    document.getElementById('play-btn').classList.replace('btn-success', 'btn-danger');\n    document.getElementById('play-btn').innerText = 'Searching for path...';\n}\n\n// This function updates the resetPath state\nfunction resetPath(setResetPath) {\n    setResetPath(true);\n}","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\nimport Header from './Header/Header';\nimport React, { useState } from 'react';\n\nexport default function App() {\n  \n  const [algo, setAlgo] = useState('');\n  const [play, setPlay] = useState(false);\n  const [resetPath, setResetPath] = useState(false);\n\n  return (\n    <div className=\"App\">\n      <Header setAlgo = { setAlgo } setPlay = { setPlay } setResetPath = { setResetPath }></Header>\n      <PathFinderVisualizer myAlgo = { algo } play = { play } reset = { resetPath } ></PathFinderVisualizer>\n    </div>\n  );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}