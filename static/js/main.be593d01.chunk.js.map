{"version":3,"sources":["Node/Node.js","algorithms/bfsOrDfs.js","algorithms/dijkstraOrAS.js","PathFinderVisualizer/PathFinderVisualizer.jsx","Header/Header.jsx","App.js","reportWebVitals.js","index.js"],"names":["NodeObj","col","row","isStart","isFinish","this","previous","cost","Infinity","heuristic","totalCost","validNeighbours","algo","paths","visited","node","dimension","nodeF","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","add","previousNode","Node","push","unshift","console","log","x1","y1","x2","y2","Math","floor","sqrt","findNodeF","prevX","prevY","getNode","newCost","abs","currentCost","newNode","h","SPEED","PathFinderVisualizer","walls","playAlgo","resetW","resetP","play","setPlay","resetWalls","setResetWalls","resetPath","setResetPath","useState","nodeS","setNodeS","setNodeF","nodes","maxRow","maxCol","currentRow","currentNode","generateGrid","bfsOrDFS","dijkstraOrAS","querySelectorAll","forEach","wall","remove","disabled","clearWalls","style","background","clearPath","id","className","map","rIndex","cIndex","onClick","placedNodeS","placedNodeF","element","length","addNode","grid","time","i","shift","pop","bfsOrDfsAlgo","timeEnd","animateAlgorithm","animatePath","changeAfterPlay","sort","a","b","dijkstraOrASAlgo","slice","visitedNodes","incrementOpacity","opacity","setTimeout","lastTime","dest","finalPath","reverse","incrementR","incrementG","r","g","replace","innerText","Header","setAlgo","setWalls","Navbar","collapseOnSelect","expand","variant","Brand","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","changeOnAlgo","Divider","Link","addWallsBtn","changeOnAddWalls","Button","playBtn","changeOnPlay","color","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.be593d01.chunk.js","sourcesContent":["export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n    heuristic;\n    totalCost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n            this.heuristic = Infinity;\n            this.totalCost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../Node/Node';\n\n// If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* SHIFT: REMOVE AT BEGINNING | PUSH: ADD AT LAST */\n    \n// If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* POP: REMOVE AT LAS | UNSHIFT: ADD AT BEGINNING */\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    while (paths.length > 0 && i <= dimension[0] * dimension[1]) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        let node = algo === 'BFS' ? paths.shift(): paths.pop();\n        console.log({node});\n        \n        // Check the valid neighbours\n        let foundNodeF = validNeighbours(algo, paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        \n        i++;\n    }\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited or if it's a wall\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\")) return true;\n\n    // If not, adds it\n    node.classList.add(\"visited\");\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(algo, paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n    // If BFS, adds the node to the end of the queue || end of the array\n    if (algo === 'BFS') {\n        paths.push(node);\n        visited.push(node);\n    // If DFS, adds the node to the top of the stack || start of the array\n    } else if (algo === 'DFS') {\n        paths.unshift(node);\n        visited.push(node);\n    }\n\n    // Check if its end node\n    if (nodeF.row === y && nodeF.col === x) {\n        node.isFinish = true;\n        console.log(`%c Found`, 'color: brown');\n        return true;\n    }\n    \n    return false;\n}","import Node from '../Node/Node';\n\n// Priority Queue\n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const dijkstraOrAS = (algo, dimension, nodeS, nodeF) => {\n\n    // Check if nodes are in the same position | Disable this when given use option\n    if (nodeS.col === nodeF.col && \n            nodeS.row === nodeF.row) {\n                return [[nodeS], false];\n    }\n\n    nodeS.cost = 0;\n    \n    // Check if AStar to add heuristic\n    if (algo === 'AStar') {\n        nodeS.heuristic = heuristic(nodeS, nodeF);\n        nodeS.totalCost = nodeS.heuristic + nodeS.cost;\n    }\n    \n    // This variable holds the open nodes\n    const paths = [nodeS];\n    // This variable holds the visited nodes\n    let visited = []\n    \n    let i = 0;\n    // While there are unvisited nodes and node not found\n    // We need also to check if loop didn't reach the maximum iteration possible to prevent browser to crash\n    while (paths.length > 0 && i <= dimension[0] * dimension[1] - 2) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let node = paths.shift();  \n        console.log('Shit');\n        console.log({node});\n        \n        // If we found the node then we should get rid of the other nodes \n        if (findNodeF(node, nodeF)) {\n            console.log(`%c Found`, 'color: brown');\n            document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n            visited.push(node);\n            \n            return [visited, true];\n        }\n    \n        // Mark as visited\n        // With the DOM manipulation, I don't have to traverse the {visited} list: O(1) \n        document.getElementById(`${node.col},${node.row}`).classList.add('visited');\n        visited.push(node);\n\n        validNeighbours(algo, paths, node, dimension, nodeF);\n\n        // Order neighbours by the cost to travel to\n        if (algo === 'AStar') {\n            paths.sort((a, b) => a.totalCost - b.totalCost);\n        } else if (algo === 'Dijkstra') {\n            paths.sort((a, b) => a.cost - b.cost);\n        } \n        //console.log({paths});\n        i++;\n    }\n\n    return [visited, false];\n}\n\n// This function calculates the heuristic\nfunction heuristic(node, nodeF) {\n\n    // Node coordinate\n    const x1 = node.col;\n    const y1 = node.row;\n    \n    // Node Finish coordinate\n    const x2 = nodeF.col;\n    const y2 = nodeF.row;\n\n    // The heuristic is the distance between the sqrt((x2-x1)² + (y2-y1)²) \n    const heuristic = Math.floor(Math.sqrt(((x2-x1) ** 2) + ((y2-y1) ** 2)));\n    //console.log(`Heuristic ${heuristic}`);\n    node.heuristic = heuristic;\n    \n    return heuristic;\n}\n\n// This function checks if a given node is the finish node\nfunction findNodeF(node, nodeF) {\n    return node.row === nodeF.row && node.col === nodeF.col;\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node.col;\n    const y = node.row;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(algo, paths, node, [x, y - 1], nodeF);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(algo, paths, node, [x + 1, y], nodeF);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(algo, paths, node, [x, y + 1], nodeF);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(algo, paths, node, [x - 1, y], nodeF);\n        }\n    }\n}\n\n// This function checks if the node was already visited\n// The reason why I am not checking the visited list\n// is due to the runtime performance\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\") || node.classList.contains(\"wall\") ) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(algo, paths, previousNode, coordinate, nodeF) {\n    \n    // Previous node coordinate\n    const prevX = previousNode.col;\n    const prevY = previousNode.row;\n    \n    // Node (neighbour) coordinate\n    const x = coordinate[0];\n    const y = coordinate[1];\n    \n    let node = getNode(paths, x, y);\n    console.log('Neighbour');\n    \n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    // This is equivallent to EDGE + ACCUMULATED COST \n    const newCost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n    \n    // Getting the cost of the node (the neighbour node) if already in paths. IF not returns Infinity\n    const currentCost = node.cost;\n\n    // This variable flags if node was updated or is new \n    const newNode = node.cost === Infinity;\n    \n    // Update the cost if cost is smaller than the node's atual cost\n    if (newCost <= currentCost) {\n        node.cost = newCost;\n        node.previous = previousNode;\n    }\n    \n    // If the algo is A* then we need to add the heuristic and update the total cost\n    if (algo === 'AStar') {\n        const h = heuristic(node, nodeF);\n        node.totalCost = node.cost + h;\n    }\n\n    // If we find the nodeF then we will flag it\n    if (findNodeF(node, nodeF)) {\n        node.isFinish = true;\n    }\n\n    console.log({node});\n    \n    // If its a new node, adds to the list\n    if (newNode) paths.push(node);\n    console.log({paths});\n}\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getNode(paths, x, y) {\n    // If it was already opened, returns the node\n    for (let node of paths) {\n        if (node.col === x && node.row === y) return node;\n    }\n\n    // Else, returns a new node\n    return new Node(x, y, false, false);\n}\n","import React, { useState } from 'react';\nimport './PathFinderVisualizer.css';\n\nimport Node from '../Node/Node';\n\n// Import the algorithm functions\nimport { bfsOrDfs as bfsOrDfsAlgo } from '../algorithms/bfsOrDfs';\nimport { dijkstraOrAS as dijkstraOrASAlgo } from '../algorithms/dijkstraOrAS';\n\nconst ROW = 20;\nconst COLUMN = 30;\n\n// // Has to be less than columns\n// const START_X = 8;\n// // Has to be less than row\n// const START_Y = 7;\n\n// // Has to be less than columns\n// const FINISH_X = 15;\n// // Has to be less than row\n// const FINISH_Y = 8;\n\nconst SPEED = 140; // The less the more speed\n\nexport default function PathFinderVisualizer({algo, walls, playAlgo, resetW, resetP}) {\n\n    // Decostructing the objects passed by arguments \n    const { play, setPlay } = playAlgo;\n    const { resetWalls, setResetWalls } = resetW;\n    const { resetPath, setResetPath } = resetP;\n\n    const [nodeS, setNodeS] = useState(new Node(-1, -1, false, false));\n    const [nodeF, setNodeF] = useState(new Node(-1, -1, false, false));\n    \n    const nodes = generateGrid(ROW, COLUMN); \n    console.log({nodes});\n\n    console.log({algo});\n    console.log({walls});\n    console.log({play});\n    console.log({resetWalls});\n    console.log({resetPath});\n\n    // Check if the play button was clicked and start the chosen algorithm\n    if (play) {\n        switch(algo) {\n            case 'BFS':\n                bfsOrDFS('BFS', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'DFS':\n                bfsOrDFS('DFS', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'Dijkstra':\n                dijkstraOrAS('Dijkstra', nodes, nodeS, nodeF, setPlay);\n                break;\n            case 'AStar':\n                dijkstraOrAS('AStar', nodes, nodeS, nodeF, setPlay);\n                break;\n            default:\n                console.log('Algo not found');\n        }\n    }\n\n    // Check if the clear walls button was clicked\n    if (resetWalls) {\n        clearWalls(setResetWalls);\n    }\n\n    // Check if the clear path button was clicked\n    if (resetPath) {\n        clearPath(setResetPath);\n    }\n\n    return (\n        <div id = 'main'>\n            <div className=\"grid\">\n                <p className = \"note\">Note: If you choose A*, for now place the finish node with min distance (col and row) of 2</p>\n                {\n                    nodes.map((row, rIndex) => {\n                        return <div key = { rIndex } className = \"grid-row\" >\n                            {\n                            row.map((node, cIndex) => {\n                                // const isStart = (cIndex === START_X && rIndex === START_Y);\n                                // const isFinish = (cIndex === FINISH_X && rIndex === FINISH_Y);\n                                //const extraClassName = isStart ? ' node-start visited': isFinish ? ' node-finish' : '';\n                                return ( \n                                    <div onClick = {() => addNode([cIndex, rIndex], [nodeS, setNodeS], [nodeF, setNodeF], walls) } \n                                        id = {`${cIndex},${rIndex}`} \n                                        className = {`node`} key = {cIndex}>\n                                    </div>\n                                )\n                            })\n                            }\n                        </div>\n                    })\n                }\n            </div>\n        </div>\n    )\n}\n\nfunction addNode(coordinate, placedNodeS, placedNodeF, walls) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    const nodeS = placedNodeS[0];\n    const nodeF = placedNodeF[0];\n\n    const setNodeS = placedNodeS[1];\n    const setNodeF = placedNodeF[1];\n\n    const element = document.getElementById(`${x},${y}`);\n\n    // // TOGGLE nodeS\n    if (element.classList.contains('node-start')) {\n        \n        element.classList.remove('node-start', 'visited');\n        setNodeS(new Node(-1, -1, false, false));\n        return ;\n    } \n\n    // TOGGLE nodeF\n    if (element.classList.contains('node-finish')) {\n    \n        element.classList.remove('node-finish');\n        setNodeF(new Node(-1, -1, false, false));\n        return ;\n    } \n\n    //Check if we have nodeS and nodeF placed. If yes, then we add walls\n    if (!nodeS.isStart) {\n\n        element.classList.add('node-start', 'visited');\n        setNodeS(new Node(x, y, true, false));\n        return ;\n    }\n    \n    if (!nodeF.isFinish) {\n        \n        element.classList.add('node-finish');\n        setNodeF(new Node(x, y, false, true));\n        return ;\n     }\n    \n    if (walls) {\n\n        const walls = document.querySelectorAll('.wall');\n        if (walls.length >= 0 ) document.getElementById('clearWalls-btn').disabled = false; // =0 because of cycle\n\n        // Toggle wall\n        if (element.classList.contains('wall')) {\n            element.classList.remove('wall');\n            return ;\n        } \n        element.classList.add('wall');\n    }\n\n    // document.getElementById('collasible-nav-dropdown').innerText = 'Choose Algorithm';\n    // document.getElementById('collasible-nav-dropdown').classList.remove('disabled');\n    \n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = `${col},${row}`;\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode);\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function handles the user click when choosing BFS or DFS\nfunction bfsOrDFS(algo, grid, nodeS, nodeF, setPlay) {\n    // DIMENSION: 0 = ROW | 1 = COLUMN\n    const dimension = [grid.length, grid[0].length];\n\n    console.time(\"runtime\");\n\n    // This variable holds the result of the BFS algorithm visisted nodes\n    // [0] = visited nodes [1] = found node\n    const nodes = bfsOrDfsAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    \n    console.timeEnd(\"runtime\");\n    console.log({visited});\n        \n    animateAlgorithm(visited);\n    if (nodes[1]) {\n        \n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The second args referes to the last node a.k.a nodeF\n        // The third args referes to the setter of the play useState\n        animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay); \n   } else {\n       changeAfterPlay(setPlay);\n   }\n}\n\n// This function handles the user click when choosing Dijsktra\nfunction dijkstraOrAS(algo, grid, nodeS, nodeF, setPlay) {\n    const dimension = [grid.length, grid[0].length];\n\n    console.time('runtime');\n    \n    const nodes = dijkstraOrASAlgo(algo, dimension, nodeS, nodeF);\n    const visited = nodes[0];\n    \n    console.timeEnd('runtime');\n    console.log({visited});\n\n    // With slice(0) we are including nodeS\n    animateAlgorithm(visited.slice(1));\n    \n    if (nodes[1]) {\n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The second args referes to the last node a.k.a nodeF\n        // The third args referes to the setter of the play useState\n        animatePath(SPEED * visited.length + 75, visited[visited.length - 1], setPlay);\n    } else {\n        changeAfterPlay(setPlay);\n    }\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n\n    const incrementOpacity = (0.7 / visitedNodes.length);  \n    let opacity = 0.3\n\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n\n        // With setTimeout, we change the color of each visited node with SPEED time between them\n        setTimeout(() => {\n            if (!node.isFinish) {\n                document.getElementById(`${node.col},${node.row}`).style.background = `rgba(109, 93, 254, ${opacity})`;\n                opacity += incrementOpacity\n            \n            } else {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"red\";\n            }\n        } , SPEED * i);\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(lastTime, nodeF, setPlay) {\n\n    // Get the last node a.k.a last visited node\n    let dest = nodeF\n    console.log({dest});\n    let finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    finalPath.reverse();\n    console.log({finalPath});\n        \n    const incrementR = Math.floor(228 / finalPath.length); \n    const incrementG = Math.floor((255 - 128) / finalPath.length); \n    let r = 0;\n    let g = 128;\n    // The last node is the nodeS, so we wont count it\n    for (let i = 1; i <= finalPath.length; i++) {\n\n        setTimeout(() => {\n            const node = finalPath[i];\n\n            if (i === finalPath.length) {\n                changeAfterPlay(setPlay);\n            } else if (i === finalPath.length - 1) {\n                document.getElementById(`${node.col},${node.row}`).style.background = \"yellow\";\n            } else {\n                r += incrementR;\n                g += incrementG;\n                document.getElementById(`${node.col},${node.row}`).style.background = `rgb(${r}, ${g}, 0)`;\n            }\n\n        // time of the last animation + time for the next animations\n        } , lastTime + (SPEED * (i - 1)));\n    }\n}\n\n// This function clears the walls\nfunction clearWalls(setResetWalls) {\n    \n    setResetWalls(false);\n\n    // Reset any stylization\n    const walls = document.querySelectorAll('.wall');\n    walls.forEach((wall) => {\n        wall.classList.remove('wall');\n    });\n\n    document.getElementById('clearWalls-btn').disabled = true;\n}\n\n// This function clears the path\nfunction clearPath(setResetPath) {\n    \n    setResetPath(false);\n\n    // Reset any stylization\n    const nodes = document.querySelectorAll('.visited');\n    nodes.forEach((node) => {\n        if (!node.classList.contains('node-start')) node.classList.remove('visited');\n        node.style.background = '';\n    });\n\n    // Set the clear path button\n    document.getElementById('clearPath-btn').disabled = true;\n    document.getElementById('play-btn').disabled = false;\n    document.getElementById('addWalls-btn').disabled = false;\n}\n\n// This functions change some elements state\nfunction changeAfterPlay(setPlay) {\n    \n    setPlay(false);\n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.remove('disabled');;\n\n    // Change play button state\n    document.getElementById('play-btn').classList.replace('btn-danger', 'btn-success');\n    document.getElementById('play-btn').innerText = 'Play';\n\n    // Change clear path state\n    document.getElementById('clearPath-btn').disabled = false;\n\n    const walls = document.querySelectorAll('.wall');\n    if (walls.length > 0 ) document.getElementById('clearWalls-btn').disabled = false;\n    \n} ","import React from 'react';\nimport './Header.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport { Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\n\nexport default function Header({ setAlgo, setWalls, setPlay, setResetWalls, setResetPath }) {\n\n    return (\n        <Navbar id=\"navbar\" collapseOnSelect expand=\"sm\" variant=\"dark\">\n            <Navbar.Brand>PathFinder</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n            <Nav className=\"mr-auto\">\n                <NavDropdown id=\"collasible-nav-dropdown\" className=\"btn\" title=\"Choose Algorithm\"  variant=\"dark\">\n                    <NavDropdown.Item onClick={() => changeOnAlgo('BFS', setAlgo)}>BFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('DFS', setAlgo)} disabled>DFS (not available yet)</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('Dijkstra', setAlgo)}>Dijkstra</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={() => changeOnAlgo('AStar', setAlgo)}>A*</NavDropdown.Item>\n                </NavDropdown>\n                <Nav.Link onClick={() => changeOnAddWalls(setWalls)}><Button id='addWalls-btn' variant=\"info\" disabled>Add Walls</Button></Nav.Link>\n                <Nav.Link onClick={() => changeOnPlay(setPlay)}><Button id='play-btn' variant=\"success\" disabled>Play</Button></Nav.Link>\n            </Nav>\n            <Nav>\n                <Nav.Link onClick = {() => resetWalls(setResetWalls)}><Button id='clearWalls-btn' variant=\"secondary\" disabled>Clear Walls</Button></Nav.Link>\n                <Nav.Link onClick = {() => resetPath(setResetPath)}><Button id='clearPath-btn' variant=\"danger\" disabled>Clear Path</Button></Nav.Link>\n            </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}\n\n/* These functions change some elements state */\nfunction changeOnAlgo(algo, setAlgo) {\n\n    setAlgo(algo);\n\n    // Manipulate the choose algorithm title\n    document.getElementById('collasible-nav-dropdown').innerText = algo;\n    document.getElementById('collasible-nav-dropdown').style.color = 'lightgreen';\n    \n    // Manipulate the play btn\n    // Only activate play and add walls btn if clear path is disabled. \n    // If it is enable it means that the user did not clear the path yet, hence not activating the play button\n    if (document.getElementById('clearPath-btn').disabled) {\n        document.getElementById('play-btn').disabled = false;\n        document.getElementById('addWalls-btn').disabled = false;\n    }\n}\n\nfunction changeOnAddWalls(setWalls) {\n    // Change add walls button state\n    const addWallsBtn = document.getElementById('addWalls-btn');\n\n    // Toggle\n    // ADD WALLS\n    if (addWallsBtn.classList.contains('btn-info')) {\n\n        setWalls(true);\n        \n        addWallsBtn.classList.replace('btn-info', 'btn-warning');\n        addWallsBtn.innerText = 'Enough of Walls';\n        \n        // Change choose algo dropdown state\n        document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n        \n        // Change play button state\n        document.getElementById('play-btn').disabled = true;\n\n    // STOP ADDING WALLS\n    } else if (addWallsBtn.classList.contains('btn-warning')) {\n        \n        setWalls(false);\n\n        addWallsBtn.classList.replace('btn-warning', 'btn-info');\n        addWallsBtn.innerText = 'Add Walls';\n\n        // Change choose algo dropdown state\n        document.getElementById('collasible-nav-dropdown').classList.remove('disabled');\n\n        // Change play button state\n        document.getElementById('play-btn').disabled = false;\n    \n    }\n}\n\nfunction changeOnPlay(setPlay) {\n    \n    setPlay(true);\n\n    const playBtn = document.getElementById('play-btn'); \n\n    // Change choose algo dropdown state\n    document.getElementById('collasible-nav-dropdown').classList.add('disabled');\n    \n    // Change add walls button state\n    document.getElementById('addWalls-btn').disabled = true;\n    \n    // Change play button state\n    playBtn.classList.replace('btn-success', 'btn-danger');\n    playBtn.innerText = 'Searching for path...';\n    playBtn.disabled = true;\n    \n    // Change clear walls button state\n    document.getElementById('clearWalls-btn').disabled = true;\n    // Change clear path button state\n    document.getElementById('clearPath-btn').disabled = true;\n}\n\n// This function updates the resetPath state\nfunction resetWalls(setResetWalls) {\n    setResetWalls(true);\n}\n\n// This function updates the resetPath state\nfunction resetPath(setResetPath) {\n    setResetPath(true);\n}","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\nimport Header from './Header/Header';\nimport React, { useState } from 'react';\n\nexport default function App() {\n  \n  const [algo, setAlgo] = useState('');\n  const [walls, setWalls] = useState(false);\n  const [play, setPlay] = useState(false);\n  const [resetWalls, setResetWalls] = useState(false);\n  const [resetPath, setResetPath] = useState(false);\n\n  return (\n    <div className=\"App\">\n      <Header \n        setAlgo = { setAlgo } setWalls = { setWalls } \n        setPlay = { setPlay } setResetWalls = { setResetWalls } setResetPath = { setResetPath }></Header>\n      <PathFinderVisualizer \n        algo = { algo } walls = { walls }\n        playAlgo = { {play, setPlay} } resetW = { {resetWalls, setResetWalls} } resetP = { {resetPath, setResetPath} }>\n       </PathFinderVisualizer>\n    </div>\n  );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}