{"version":3,"sources":["Node/Node.jsx","Node/NodeObj.js","algorithms/bfsOrDfs.js","algorithms/dijkstra.js","algorithms/aStar.js","PathFinderVisualizer/PathFinderVisualizer.jsx","Header/Header.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","isStart","isFinish","coordinates","extraClassName","id","className","React","Component","NodeObj","col","row","previous","cost","Infinity","bfsOrDfs","algo","dimension","nodeS","nodeF","paths","visited","i","length","console","log","node","shift","pop","validNeighbours","maxRows","maxColums","x","y","wasVisited","addVisitedNode","coordinate","document","getElementById","classList","contains","add","previousNode","push","unshift","findNodeF","prevX","prevY","Math","abs","visitedCost","getVisitedCost","realCost","min","PathFinderVisualizer","nodes","maxRow","maxCol","start","finish","currentRow","currentNode","generateGrid","setState","querySelectorAll","forEach","style","background","grid","time","timeEnd","animateAlgorithm","animatePath","indexF","indexOf","slice","sort","a","b","dijkstraAlgo","choosenAlgo","map","rIndex","nodeIndex","onClick","bfs","dfs","dijsktra","disabled","aStar","visitedNodes","setTimeout","lastTime","dest","finalPath","Header","triggerAlgo","playAlgo","Navbar","collapseOnSelect","expand","variant","Brand","href","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","chooseAlgo","bind","Divider","Link","Button","App","play","getAlgoFromHeader","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.491a9022.chunk.js","sourcesContent":["import React from 'react';\nimport './Node.css';\n\nexport default class Node extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {}\n    }\n\n    render() {\n        // Getting the attributes (Passed in PathfinderVisualizer.jsx render() <Node [atributtes]>)\n        const { isStart, isFinish, coordinates } = this.props;\n        const extraClassName = isStart ? 'node-start visited': isFinish ? 'node-finish' : '';\n\n        return <div id={`${ coordinates }`} className={`node ${ extraClassName }`}></div>;\n    }\n\n}","export default class NodeObj {\n    col; \n    row;\n    isStart;\n    isFinish;\n    previous;\n    cost;\n\n    constructor(\n        col, row, isStart, isFinish) {\n            this.col = col;\n            this.row = row;\n            this.isStart = isStart;\n            this.isFinish = isFinish;\n            this.previous = null;\n            this.cost = Infinity;\n    }\n\n}","// This function implements the BFS algorithm and returns the visited nodes\nimport Node from '../Node/NodeObj';\n\n// If BFS = QUEUE (FIFO)\n    // BFS find the shortest path by repeatedly visiting the adjacent node\n    // My analogy: The parent node likes all his children \n    // and once the children becomes a parent, the pattern repeats\n    \n    /* PUSH: ADD AT LAST | POP: REMOVE AT LAST*/\n    \n    // If DFS = STACK (LIFO)\n    // DFS find the shortest path by repeatedly visiting the open/atual node till not possible\n    // My analogy: The parent node just likes one of his children\n    // and once the child becomes a parent, the pattern repeats\n    \n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const bfsOrDfs = (algo, dimension, nodeS, nodeF) => {\n\n    if (nodeS[\"col\"] === nodeF[\"col\"] && \n            nodeS[\"row\"] === nodeF[\"row\"]) {\n                return [[nodeS], false];\n    }\n\n    // This variable holds the open nodes (coordinate) [x, y]\n    const paths = [nodeS];\n    let visited = []\n\n    let i = 0;\n    // While the are nodes to visit\n    while (paths.length > 0) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        // If BFS, removes node from the start of the queue || start of the array\n        // If DFS, removes node from the top of the stack || end of the array\n        let node = algo === 'BFS' ? paths.shift(): paths.pop();\n        console.log({node});\n        \n        // Check the valid neighbours\n        let foundNodeF = validNeighbours(algo, paths, visited, node, dimension, nodeF);\n\n        // If node equal to undefined means that we found nodeF\n        if (foundNodeF) {\n            return [visited, true];\n        }\n        i++;\n    }\n\n    console.log({visited})\n    console.log({paths})\n    return [visited, false];\n\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(algo, paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node[\"col\"];\n    const y = node[\"row\"];\n\n    let isNodeF = false;\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        // if DFS, break\n        if (!wasVisited([x, y - 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y - 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x + 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x, y + 1], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            isNodeF = addVisitedNode(algo, paths, visited, node, [x - 1, y], nodeF);\n            if (isNodeF) return true;\n            if (algo === 'DFS') return ;\n        }\n    }\n\n    return ;\n}\n\n// This function checks if the node was already visited\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\")) return true;\n\n    // If not, adds it\n    node.classList.add(\"visited\");\n    return false;\n}\n\n// This function adds the visited node accordingly to the algorithm\n// Return true or false whether the nodeF was found\nfunction addVisitedNode(algo, paths, visited, previousNode, coordinate, nodeF) {\n\n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    let node = new Node(x, y, false, false);\n    node.previous = previousNode;\n\n    // If BFS, adds the node to the end of the queue || end of the array\n    if (algo === 'BFS') {\n        paths.push(node);\n        visited.push(node);\n\n    // If DFS, adds the node to the top of the stack || start of the array\n    } else {\n        paths.unshift(node);\n        visited.push(node);\n    }\n\n    // Check if its end node\n    if (nodeF[\"row\"] === y && nodeF[\"col\"] === x) {\n        node.isFinish = true;\n        console.log(`%c Found`, 'color: brown');\n        return true;\n    }\n    \n    return false;\n}","import Node from '../Node/NodeObj';\n\n// Priority Queue\n    /* UNSHIFT: ADD AT BEGINNING | SHIFT: REMOVE AT BEGINNING */\n\nexport const dijkstraAlgo = (dimension, nodeS, nodeF) => {\n\n    // Check if nodes are in the same position | Disable this when given use option\n    if (nodeS[\"col\"] === nodeF[\"col\"] && \n            nodeS[\"row\"] === nodeF[\"row\"]) {\n                return [[nodeS], false];\n    }\n\n    nodeS.cost = 0;\n    // This variable holds the open nodes\n    const paths = [nodeS];\n    let visited = []\n    \n    let i = 0;\n    while (paths.length > 0) {\n        console.log(`%c Loop ${i}`, 'color: red');\n\n        let node = paths.shift();\n        \n        // If we found the node then we should get rid of the other nodes \n        if (findNodeF(node, nodeF)) {\n\n            let indexF = 0;\n            for (let i = 0; i < visited.length; i++) {\n                if (visited[i].isFinish) {\n                    indexF = visited.indexOf(visited[i]);\n                    break;\n                }\n            }\n         \n            visited = visited.slice(0, indexF + 1);\n    \n            return [visited, true];\n        }\n            \n    \n        // Mark as visited\n        document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).classList.add('visited');\n        visited.push(node);\n\n        validNeighbours(paths, visited, node, dimension, nodeF);\n\n        // Order neighbours by the cost to travel to\n        paths.sort((a, b) => a.cost - b.cost); \n        //console.log({paths});\n        i++;\n    }\n\n    return [visited, false];\n}\n\n// This function checks if a given node is the finish node\nfunction findNodeF(node, nodeF) {\n    return node[\"row\"] === nodeF[\"row\"] && node[\"col\"] === nodeF[\"col\"];\n}\n\n// This functions checks the neighbours and returns a list of the visited (valid) ones \nfunction validNeighbours(paths, visited, node, dimension, nodeF) {\n\n    /* GRID DIMENSION: 0 = ROW | 1 = COLUMN */\n    const maxRows = dimension[0]; \n    const maxColums = dimension[1]; \n\n    // Getting the coordinate of the given node\n    const x = node[\"col\"];\n    const y = node[\"row\"];\n\n    // Checks UP\n    if (y - 1 >= 0) {\n        // Check if it was visited already\n        if (!wasVisited([x, y - 1])) {\n            addVisitedNode(paths, visited, node, [x, y - 1], nodeF);\n        }\n    }\n    \n    // Checks RIGHT\n    if (x + 1 <= maxColums - 1) {\n        if (!wasVisited([x + 1, y])) {\n            addVisitedNode(paths, visited, node, [x + 1, y], nodeF);\n        }\n    }\n    \n    // Checks DOWN\n    if (y + 1 <= maxRows - 1) {\n        if (!wasVisited([x, y + 1])) {\n            addVisitedNode(paths, visited, node, [x, y + 1], nodeF);\n        }\n    }\n    \n    // Checks LEFT\n    if (x - 1 >= 0) {\n        if (!wasVisited([x - 1, y])) {\n            addVisitedNode(paths, visited, node, [x - 1, y], nodeF);\n        }\n    }\n}\n\n// This function checks if the node was already visited\n// The reason why I am not checking the visited list\n// is due to the runtime performance\nfunction wasVisited(coordinate) {\n    const node = document.getElementById(`${coordinate[0]},${coordinate[1]}`);\n    \n    // Check if the node as a visited \"flag\"\n    if (node.classList.contains(\"visited\")) return true;\n\n    return false;\n}\n\n// This function adds the adjacent nodes\nfunction addVisitedNode(paths, visited, previousNode, coordinate, nodeF) {\n\n    const prevX = previousNode[\"col\"];\n    const prevY = previousNode[\"row\"];\n    \n    const x = coordinate[0];\n    const y = coordinate[1];\n\n    // Because the direction is horizontal OR vertical\n    // Is safe to do diff(x) + diff(y) because one of them will be 0\n    // This is equivallent to EDGE + ACCUMULATED COST \n    const cost = Math.abs(x - prevX) + Math.abs(y - prevY) + previousNode.cost;\n\n    // Getting the cost of the node (the neighbour node)\n    const visitedCost = getVisitedCost(paths, x, y);\n\n    // Update the cost if cost is smaller than the node's atual cost\n    const realCost = Math.min(cost, visitedCost);\n\n    let node = new Node(x, y, false, false);\n    node.cost = realCost;\n    node.previous = previousNode;\n\n    \n    if (findNodeF(node, nodeF)) {\n        node.isFinish = true\n    }\n\n    paths.push(node);\n    visited.push(node);\n}\n\n// This function returs the current cost of the node of coordinate (x, y)\nfunction getVisitedCost(paths, x, y) {\n    for (let node in paths) {\n        if (node[\"col\"] === x && node[\"row\"] === y) return node.cost;\n    }\n    return Infinity;\n}","export const aStarAlgo = (dimension, nodeS, nodeF) => {\n    // def a_star(graph, start, goal):\n    // q = [(start, [],0,10, 10)]\n    // print('q inicial ', q)\n    // done = []\n    // while q:\n    //     print(q)\n    //     (vertex, path, custo, heuristic, total) = q.pop(0)\n    //     if vertex == goal:\n    //         print('Custo total ', custo)\n    //         yield path + [vertex]\n    //     done.append(vertex)\n    //     for next in graph[vertex] - set(path):\n    //         if next[0] not in done:\n    //             custo =  next[1]\n    //             heuristic = next[2]\n    //             total = custo + heuristic\n    //             #custo  = custo + next[1]\n    //         # sorted(path + [next], key = lambda x: x[1])\n    //             q.append((next[0], path + [vertex], custo, heuristic, total))\n    //             custo = custo + next[1]\n    //             q.sort(key=lambda x:x[4])\n} ","import React from 'react';\nimport './PathFinderVisualizer.css';\n\nimport Node from '../Node/Node';\nimport NodeObj from '../Node/NodeObj';\n\n// Import the algorithm functions\nimport { bfsOrDfs } from '../algorithms/bfsOrDfs';\nimport { dijkstraAlgo } from '../algorithms/dijkstra';\nimport { aStarAlgo } from '../algorithms/aStar';\n\nconst ROW = 20;\nconst COLUMN = 30;\n\n// Has to be less than columns\nconst START_X = 5;\n// Has to be less than row\nconst START_Y = 5;\n\n// Has to be less than columns\nconst FINISH_X = 10;\n// Has to be less than row\nconst FINISH_Y = 8;\n\nconst SPEED = 60; // The less the more\n\nexport default class PathFinderVisualizer extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            nodes: []\n        }\n    }\n\n    componentDidMount() {\n        // Generate a grid with args1 rows and args2 columns \n        // and starting node in **coordinates** args3 \n        // and ending node in **coordinates** args4 \n        let nodes = generateGrid(ROW, COLUMN, [START_X, START_Y],[FINISH_X, FINISH_Y]);\n        this.setState({nodes});\n    }\n\n    // This function resets the grid\n    resetGrid() {\n        // Reset any stylization\n        let nodes = document.querySelectorAll('.node'); \n        nodes.forEach((node) => {\n            if (node.style.background !== '') node.style.background = '';\n        });\n\n        // Not working properly\n        // this.componentDidMount();\n    }\n\n    // This function handles the user click when choosing BFS\n    bfs(grid, nodeS, nodeF) {\n        // DIMENSION: 0 = ROW | 1 = COLUMN\n        const dimension = [grid.length, grid[0].length];\n\n        console.time(\"bfs\");\n\n        // This variable holds the result of the BFS algorithm visisted nodes\n        // [0] = visited nodes [1] = found node\n        const nodes = bfsOrDfs('BFS', dimension, nodeS, nodeF);\n        const visited = nodes[0];\n        console.log({visited});\n        \n        console.timeEnd(\"bfs\");\n        \n        console.time(\"bfs animate algo\");\n        animateAlgorithm(visited);\n        console.timeEnd(\"bfs animate algo\");\n        \n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The seconde args return the last node a.k.a nodeF\n        if (nodes[1]) animatePath(SPEED * visited.length + 50, visited[visited.length - 1]); \n    }\n    \n    // This function handles the user click when choosing DFS\n    dfs(grid, nodeS, nodeF) {\n        // DIMENSION: 0 = ROW | 1 = COLUMN\n        const dimension = [grid.length, grid[0].length];\n        \n        console.time(\"dfs\");\n\n        // This variable holds the result of the DFS algorithm visisted nodes\n        const nodes = bfsOrDfs('DFS', dimension, nodeS, nodeF);\n        const visited = nodes[0];\n        console.log({visited});\n\n        console.timeEnd(\"dfs\");\n        \n        console.time(\"dfs animate algo\");\n        animateAlgorithm(visited);\n        console.timeEnd(\"dfs animate algo\");\n        \n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The seconde args return the last node a.k.a nodeF\n        if (nodes[1]) animatePath(SPEED * visited.length + 50, visited[visited.length - 1]); \n    }\n    \n    // This function handles the user click when choosing Dijsktra\n    dijsktra(grid, nodeS, nodeF) {\n        const dimension = [grid.length, grid[0].length];\n\n        console.time('dijkstra');\n        \n        const nodes = dijkstraAlgo(dimension, nodeS, nodeF);\n        const visited = nodes[0];\n        console.log({visited});\n\n        console.timeEnd('dijkstra');\n\n        console.time(\"dijkstra animate algo\"); \n        // With slice(0) we are including nodeS\n        animateAlgorithm(visited.slice(1));\n        console.timeEnd(\"dijkstra animate algo\");\n\n        // The first args refers to the time that the animateAlgorithm finished + 50ms\n        // The seconde args return the last node a.k.a nodeF\n        if (nodes[1]) animatePath(SPEED * visited.length + 50, visited[visited.length - 1]);\n    }\n    \n    // This function handles the user click when choosing A*\n    aStar(grid, nodeS, nodeF) {\n        const dimension = [grid.length, grid[0].length];\n        aStarAlgo(dimension, nodeS, nodeF);\n    }\n\n    render() {\n        // Getting the nodes/grid\n        const { nodes, choosenAlgo } = this.state;\n        let nodeS;\n        let nodeF;\n        console.log({nodes});\n        console.log({choosenAlgo});\n        return (\n            <div className= \"container-fluid\">\n           <div className=\"grid\">\n               {\n                  nodes.map((row, rIndex) => {\n                      return <div key={rIndex} className=\"grid-row\">\n                        {\n                          row.map((node, nodeIndex) => {\n                            const { isStart, isFinish, col, row} = node;\n                            if (isStart) nodeS = node;\n                            if (isFinish) nodeF = node;\n                            return <Node  \n                                coordinates={`${col},${row}`} key={nodeIndex}\n                                isStart = {isStart} isFinish = {isFinish}\n                            ></Node>\n                          })\n                        }\n                        </div>\n                    })\n               }\n               <div className=\"buttons\">\n                   <button onClick={() => this.bfs(nodes, nodeS, nodeF)}>BFS</button>\n                   <button onClick={() => this.dfs(nodes, nodeS, nodeF)}>DFS</button>\n                   <button onClick={() => this.dijsktra(nodes, nodeS, nodeF)}>Dijkstra</button>\n                   <button disabled onClick={() => this.aStar(nodes, nodeS, nodeF)}>A*</button>\n                   <button className=\"resetGrid\" disabled/*onClick={() => this.resetGrid()*} */>Clear path</button>\n               </div>\n           </div>\n           </div>\n        )\n    }\n}\n\n// This function generates the grid\nfunction generateGrid(maxRow, maxCol, start, finish) {\n    const nodes = [];\n        for (let row = 0; row < maxRow; row++) {\n            const currentRow = [];\n\n            for (let col = 0; col < maxCol; col++) {\n                // Defining the node object\n                // Col, Row, isStart, isFinish \n                const currentNode = new NodeObj(\n                    col,\n                    row,\n                    row === start[1] && col === start[0],\n                    row === finish[1] && col === finish[0]\n                );\n\n                // Saving the column nodes in each row\n                currentRow.push(currentNode);\n            }\n\n            // Saving the rows\n            nodes.push(currentRow);\n        }\n    return nodes;\n}\n\n// This function animates each visited node\nfunction animateAlgorithm(visitedNodes) {\n    for (let i = 0; i < visitedNodes.length; i++) {\n        let node = visitedNodes[i];\n        if (i !== visitedNodes.length - 1) {\n            // With setTimeout, we change the color of each visited node with 145ms  between them\n            setTimeout(() => {\n                if (!node.isFinish) {\n                    document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"lightblue\";\n                } else {\n                    document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"red\";\n                }\n            } , SPEED * i);\n        }\n    }\n}\n\n// This function animates the path from the starting node to the finishing node \n// The animated path will be the one which as the minimum previous nodes\nfunction animatePath(lastTime, nodeF) {\n\n    // Get the last node a.k.a last visited node\n    let dest = nodeF\n    console.log({dest});\n    const finalPath = [];\n\n    // While we dont reach the start node, backtracks\n     while(dest !== null) {\n        finalPath.push(dest);\n        dest = dest.previous;    \n    }\n        \n    console.log({finalPath});\n        \n    // The last node is the nodeS, so we wont count it\n    for (let i = finalPath.length - 2; i >= 0; i--) {\n        setTimeout(() => {\n            const node = finalPath[i]\n            if (node.isFinish) {\n                document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"yellow\";\n            } else {\n                document.getElementById(`${node[\"col\"]},${node[\"row\"]}`).style.background = \"purple\";\n            }\n           // time of the last animation + time for the next animations\n        } , lastTime + ( SPEED * (finalPath.length - i) ));\n    }\n}\n","import React from 'react';\nimport './Header.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport {Navbar, Nav, NavDropdown, Button } from 'react-bootstrap';\n\nexport default class Header extends React.Component {\n\n    chooseAlgo (algo) {\n        this.props.triggerAlgo(algo);   \n    }\n\n    playAlgo() {\n        this.props.playAlgo();\n    }\n\n    render() {\n        return (\n            <Navbar id=\"navbar\" collapseOnSelect expand=\"sm\" variant=\"dark\">\n                <Navbar.Brand href=\"#home\">PathFinder</Navbar.Brand>\n                <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n                <Navbar.Collapse id=\"responsive-navbar-nav\">\n                <Nav className=\"mr-auto\">\n                    <NavDropdown title=\"Choose Algorithm\" id=\"collasible-nav-dropdown\" variant=\"dark\" disabled>\n                    <NavDropdown.Item onClick={ this.chooseAlgo.bind(this, 'BFS') }>BFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={ this.chooseAlgo.bind(this, 'DFS') }>DFS</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={ this.chooseAlgo.bind(this, 'Dijkstra') }>Dijkstra</NavDropdown.Item>\n                    <NavDropdown.Divider/>\n                    <NavDropdown.Item onClick={ this.chooseAlgo.bind(this, 'A*') }>A*</NavDropdown.Item>\n                    </NavDropdown>\n                    <Nav.Link><Button variant=\"info\" disabled>Add Walls</Button></Nav.Link>\n                    <Nav.Link><Button variant=\"success\" disabled>Play</Button></Nav.Link>\n                </Nav>\n                <Nav>\n                    <Nav.Link><Button variant=\"warning\" disabled>Clear Walls</Button></Nav.Link>\n                    <Nav.Link><Button variant=\"danger\" disabled>Clear Path</Button></Nav.Link>\n                </Nav>\n                </Navbar.Collapse>\n            </Navbar>\n        )\n    }\n\n}","import './App.css';\nimport PathFinderVisualizer from './PathFinderVisualizer/PathFinderVisualizer';\nimport Header from './Header/Header';\nimport React from 'react';\n\n\nexport class App extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      algo: '',\n      play: false\n    }\n\n    // this.getAlgo = this.getAlgo.bind(this);\n  }\n\n  getAlgoFromHeader(algo) {\n    console.log('Worked')\n    this.setState({ algo: algo });\n  }\n\n  // playAlgo() {\n  //   this.setState({ play: true}); \n  // }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Header triggerAlgo = { this.getAlgoFromHeader.bind(this)}></Header>\n        <PathFinderVisualizer choosenAlgo = {this.state.algo}></PathFinderVisualizer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}